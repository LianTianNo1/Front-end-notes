<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>校招每日一题 1月 | 前端学习@小浪努力学前端</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="小浪努力学前端之旅">
    
    <link rel="preload" href="/Front-end-notes/assets/css/0.styles.102086c6.css" as="style"><link rel="preload" href="/Front-end-notes/assets/js/app.fce70604.js" as="script"><link rel="preload" href="/Front-end-notes/assets/js/3.b45189e7.js" as="script"><link rel="preload" href="/Front-end-notes/assets/js/1.62c193a0.js" as="script"><link rel="preload" href="/Front-end-notes/assets/js/51.dc86cabf.js" as="script"><link rel="prefetch" href="/Front-end-notes/assets/js/10.6cc78502.js"><link rel="prefetch" href="/Front-end-notes/assets/js/11.458a0b3d.js"><link rel="prefetch" href="/Front-end-notes/assets/js/12.95ba9ad9.js"><link rel="prefetch" href="/Front-end-notes/assets/js/13.3a02c30b.js"><link rel="prefetch" href="/Front-end-notes/assets/js/14.323ca1f4.js"><link rel="prefetch" href="/Front-end-notes/assets/js/15.6056f1f6.js"><link rel="prefetch" href="/Front-end-notes/assets/js/16.fc2feb67.js"><link rel="prefetch" href="/Front-end-notes/assets/js/17.ceaa1fd9.js"><link rel="prefetch" href="/Front-end-notes/assets/js/18.2d178623.js"><link rel="prefetch" href="/Front-end-notes/assets/js/19.b128f84d.js"><link rel="prefetch" href="/Front-end-notes/assets/js/20.0dc80967.js"><link rel="prefetch" href="/Front-end-notes/assets/js/21.be333256.js"><link rel="prefetch" href="/Front-end-notes/assets/js/22.d4b56230.js"><link rel="prefetch" href="/Front-end-notes/assets/js/23.aadd69ba.js"><link rel="prefetch" href="/Front-end-notes/assets/js/24.b819f4f9.js"><link rel="prefetch" href="/Front-end-notes/assets/js/25.6ac4bf48.js"><link rel="prefetch" href="/Front-end-notes/assets/js/26.52426858.js"><link rel="prefetch" href="/Front-end-notes/assets/js/27.f9af1eb3.js"><link rel="prefetch" href="/Front-end-notes/assets/js/28.ba4a0075.js"><link rel="prefetch" href="/Front-end-notes/assets/js/29.9c07955a.js"><link rel="prefetch" href="/Front-end-notes/assets/js/30.042e1c76.js"><link rel="prefetch" href="/Front-end-notes/assets/js/31.f58210b8.js"><link rel="prefetch" href="/Front-end-notes/assets/js/32.391c87a8.js"><link rel="prefetch" href="/Front-end-notes/assets/js/33.31ce1fc3.js"><link rel="prefetch" href="/Front-end-notes/assets/js/34.158603c0.js"><link rel="prefetch" href="/Front-end-notes/assets/js/35.2b343ddd.js"><link rel="prefetch" href="/Front-end-notes/assets/js/36.bc27222b.js"><link rel="prefetch" href="/Front-end-notes/assets/js/37.6e382158.js"><link rel="prefetch" href="/Front-end-notes/assets/js/38.69e339d8.js"><link rel="prefetch" href="/Front-end-notes/assets/js/39.f62448eb.js"><link rel="prefetch" href="/Front-end-notes/assets/js/4.769817e4.js"><link rel="prefetch" href="/Front-end-notes/assets/js/40.969f7bb7.js"><link rel="prefetch" href="/Front-end-notes/assets/js/41.bba09bbb.js"><link rel="prefetch" href="/Front-end-notes/assets/js/42.2a5c9752.js"><link rel="prefetch" href="/Front-end-notes/assets/js/43.6c64a210.js"><link rel="prefetch" href="/Front-end-notes/assets/js/44.5bf91ad0.js"><link rel="prefetch" href="/Front-end-notes/assets/js/45.ca36ffa1.js"><link rel="prefetch" href="/Front-end-notes/assets/js/46.a38594e4.js"><link rel="prefetch" href="/Front-end-notes/assets/js/47.f7d12bf2.js"><link rel="prefetch" href="/Front-end-notes/assets/js/48.eb22b960.js"><link rel="prefetch" href="/Front-end-notes/assets/js/49.62394b38.js"><link rel="prefetch" href="/Front-end-notes/assets/js/5.c118bdde.js"><link rel="prefetch" href="/Front-end-notes/assets/js/50.8e98f317.js"><link rel="prefetch" href="/Front-end-notes/assets/js/52.cb455536.js"><link rel="prefetch" href="/Front-end-notes/assets/js/6.484272e5.js"><link rel="prefetch" href="/Front-end-notes/assets/js/7.76f986b7.js"><link rel="prefetch" href="/Front-end-notes/assets/js/8.6a620588.js"><link rel="prefetch" href="/Front-end-notes/assets/js/9.39185153.js">
    <link rel="stylesheet" href="/Front-end-notes/assets/css/0.styles.102086c6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1aefc0b4><div data-v-1aefc0b4><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1aefc0b4 data-v-1aefc0b4><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>前端学习@小浪努力学前端</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>小浪努力学前端之旅</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-1aefc0b4><header class="navbar" data-v-1aefc0b4><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Front-end-notes/" class="home-link router-link-active"><!----> <span class="site-name">前端学习@小浪努力学前端</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Front-end-notes/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      小浪前端博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/LianTianNo1" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4098610193243789/posts" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1aefc0b4></div> <aside class="sidebar" data-v-1aefc0b4><div class="personal-info-wrapper" data-v-39576ba9 data-v-1aefc0b4><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>23</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/Front-end-notes/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      小浪前端博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/LianTianNo1" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4098610193243789/posts" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/Front-end-notes/" class="sidebar-heading clickable router-link-active"><span>🥏欢迎🥏</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-notes/" aria-current="page" class="sidebar-link">🥚前言</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Front-end-notes/algorithm/start" class="sidebar-heading clickable"><span>算法学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-notes/algorithm/start.html" class="sidebar-link">🦁开始</a></li><li><a href="/Front-end-notes/algorithm/struct.html" class="sidebar-link">🐇基础数据结构</a></li><li><a href="/Front-end-notes/algorithm/algorithm.html" class="sidebar-link">🦀解题技巧与必会算法</a></li><li><a href="/Front-end-notes/algorithm/leetcode.html" class="sidebar-link">🐈leetCode必刷题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Front-end-notes/handbook/Webbase" class="sidebar-heading clickable"><span>基础学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-notes/handbook/Webbase.html" class="sidebar-link">🐰Web基础</a></li><li><a href="/Front-end-notes/handbook/ComputerNetwork.html" class="sidebar-link">🐣计算机网络</a></li><li><a href="/Front-end-notes/handbook/StudyGit.html" class="sidebar-link">🐍必会的Git</a></li><li><a href="/Front-end-notes/handbook/LearningAlgorithm.html" class="sidebar-link">🐠小浪学习算法笔记</a></li><li><a href="/Front-end-notes/handbook/DoExercises.html" class="sidebar-link">🐋leetCode刷题1</a></li><li><a href="/Front-end-notes/handbook/DoExercises1.html" class="sidebar-link">🐋leetCode刷题2</a></li><li><a href="/Front-end-notes/handbook/ReviewNodeJS.html" class="sidebar-link">⏲小浪复习NodeJS框架</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Front-end-notes/collection/1" class="sidebar-heading clickable"><span>收藏的其他大佬文章</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-notes/collection/1.html" class="sidebar-link">🐇前端面试复习计划</a></li><li><a href="/Front-end-notes/collection/2.html" class="sidebar-link">🏆最全的手写JS面试题</a></li><li><a href="/Front-end-notes/collection/3.html" class="sidebar-link">🎲最全的TypeScript学习指南</a></li><li><a href="/Front-end-notes/collection/4.html" class="sidebar-link">⚾前端硬核面试专题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Front-end-notes/beautyAlgorithms/1" class="sidebar-heading clickable"><span>猫哥的技术博客：JavaScript 数据结构与算法之美</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-notes/beautyAlgorithms/1.html" class="sidebar-link">⚡时间和空间复杂度</a></li><li><a href="/Front-end-notes/beautyAlgorithms/2.html" class="sidebar-link">⚡线性表（数组、队列、栈、链表）</a></li><li><a href="/Front-end-notes/beautyAlgorithms/3.html" class="sidebar-link">⚡实现一个前端路由，如何实现浏览器的前进与后退 ？</a></li><li><a href="/Front-end-notes/beautyAlgorithms/4.html" class="sidebar-link">⚡栈内存与堆内存 、浅拷贝与深拷贝</a></li><li><a href="/Front-end-notes/beautyAlgorithms/5.html" class="sidebar-link">⚡递归</a></li><li><a href="/Front-end-notes/beautyAlgorithms/6.html" class="sidebar-link">⚡非线性表（树、堆）</a></li><li><a href="/Front-end-notes/beautyAlgorithms/7.html" class="sidebar-link">⚡冒泡排序、选择排序、插入排序</a></li><li><a href="/Front-end-notes/beautyAlgorithms/8.html" class="sidebar-link">⚡归并排序、快速排序、希尔排序、堆排序</a></li><li><a href="/Front-end-notes/beautyAlgorithms/9.html" class="sidebar-link">⚡计数排序、桶排序、基数排序</a></li><li><a href="/Front-end-notes/beautyAlgorithms/10.html" class="sidebar-link">⚡十大经典排序算法汇总</a></li><li><a href="/Front-end-notes/beautyAlgorithms/11.html" class="sidebar-link">⚡GitHub 上 170K+ Star 的前端学习的数据结构与算法项目</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Front-end-notes/studyeveryday/study2022-1" class="sidebar-heading clickable open active"><span>群友每日一题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-notes/studyeveryday/study2022-1.html" aria-current="page" class="active sidebar-link">🚀2022年1月</a></li><li><a href="/Front-end-notes/studyeveryday/study2022-2.html" class="sidebar-link">🙀2022年2月</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Front-end-notes/offerShare/1" class="sidebar-heading clickable"><span>三位大佬最强面试资源</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Front-end-notes/offerShare/1.html" class="sidebar-link">📙1 前端面试准备</a></li><li><a href="/Front-end-notes/offerShare/2.html" class="sidebar-link">🔰2 程序员面试软技能</a></li><li><a href="/Front-end-notes/offerShare/3.html" class="sidebar-link">🔱3 offer收割机之HTML篇</a></li><li><a href="/Front-end-notes/offerShare/4.html" class="sidebar-link">🔮4 offer收割机之CSS篇</a></li><li><a href="/Front-end-notes/offerShare/5.html" class="sidebar-link">🔥5 offer收割机之JavaScript篇</a></li><li><a href="/Front-end-notes/offerShare/6.html" class="sidebar-link">🔔6 offer收割机之性能优化篇</a></li><li><a href="/Front-end-notes/offerShare/7.html" class="sidebar-link">🔍7 offer收割机之前端工程化篇</a></li><li><a href="/Front-end-notes/offerShare/8.html" class="sidebar-link">🔑8 offer收割机之计算机网络篇</a></li><li><a href="/Front-end-notes/offerShare/9.html" class="sidebar-link">🔓9 offer收割机之浏览器原理篇</a></li><li><a href="/Front-end-notes/offerShare/10.html" class="sidebar-link">📻10 offer收割机之手写代码篇</a></li><li><a href="/Front-end-notes/offerShare/11.html" class="sidebar-link">📷11 offer收割机之代码输出篇</a></li><li><a href="/Front-end-notes/offerShare/12.html" class="sidebar-link">📦12 LeetCode面试常考题目</a></li><li><a href="/Front-end-notes/offerShare/13.html" class="sidebar-link">📛13 offer收割机之Vue篇</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2></h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-1aefc0b4><main class="page"><section><div class="page-title"><h1 class="title">校招每日一题 1月</h1> <div data-v-f875f3fc><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="校招每日一题-1月"><a href="#校招每日一题-1月" class="header-anchor">#</a> 校招每日一题 1月</h1> <h2 id="_2022-01-12"><a href="#_2022-01-12" class="header-anchor">#</a> 2022.01.12</h2> <h3 id="_1、css篇-定位中-absolute-与-fixed-共同点与不同点"><a href="#_1、css篇-定位中-absolute-与-fixed-共同点与不同点" class="header-anchor">#</a> 1、css篇：定位中，absolute 与 fixed 共同点与不同点</h3> <blockquote><p>共同点：</p></blockquote> <ul><li>改变行内元素的呈现方式，将 display 置为 inline-block</li> <li>使元素脱离普通文档流，不再占据文档物理空间</li> <li>覆盖非定位文档元素</li></ul> <blockquote><p>不同点：</p></blockquote> <ul><li>abuselute 与 fixed 的根元素不同，abuselute 的根元素可以设置，fixed 根元素是浏览器。</li> <li>在有滚动条的页面中，absolute 会跟着父元素进行移动，fixed 固定在页面的具体位置。</li></ul> <blockquote><p>自己总结</p></blockquote> <ul><li><p>fixed定位和absolute定位都脱离了标准文档流，</p></li> <li><p>未设置偏移量时，都定位在父元素的左上</p></li> <li><p>fixed以浏览器窗口为参照物而absolute以父元素</p></li> <li><p>补充一下：fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p></li></ul> <h3 id="_2、javascript篇-闭包的概念及特点"><a href="#_2、javascript篇-闭包的概念及特点" class="header-anchor">#</a> 2、JavaScript篇：闭包的概念及特点</h3> <blockquote><p>1、概念</p></blockquote> <ul><li>闭包函数：声明在一个函数中的函数，叫做闭包函数。</li> <li>闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</li></ul> <blockquote><p>2、特点</p></blockquote> <ul><li>让外部访问函数内部变量成为可能；</li> <li>局部变量会常驻在内存中；</li> <li>可以避免使用全局变量，防止全局变量污染；</li> <li>会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</li></ul> <blockquote><p>3、缺点</p></blockquote> <ul><li>【1】可能导致<em>内存溢出</em>（面试高频）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// new Array(1000000)定义一个长度为1000000的数组</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'------'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token comment">// 这个代码会导致内存溢出 浏览器会做一个崩溃的设置 终止程序</span>
</code></pre></div><p>内存溢出是指存储的数据超出了指定空间的大小，这时数据就会越界</p> <ul><li>【2】可能会导致<em>内存泄露</em></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">[</span><span class="token number">10000000</span><span class="token punctuation">]</span>
    <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> fn2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// fn1形成闭包 本该释放的arr变量现在不会被释放！</span>
</code></pre></div><p><strong>内存泄漏</strong>的意思：变量占用内存的事件可能会过长（毕竟延长了局部变量的生命周期嘛~ 申请的内存空间没有被正确释放，导致后续程序里这块内存被永远占用（不可达））——</p> <blockquote><p>简单来说就是：闭包会常驻内存，增加内存使用量。</p></blockquote> <p>所以需要及时释放——</p> <p>【2.1】解决内存泄漏的方法让<strong>内部函数对象</strong>f成为垃圾对象！！</p> <div class="language-js extra-class"><pre class="language-js"><code> f <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 解放空间！</span>
</code></pre></div><p>【2.2】我们可以利用垃圾回收机制销毁内存中的闭包或者手动销毁，上面提到了手动销毁，而垃圾回收机制有如下方法——</p> <ul><li>标记清除法</li> <li>循环计数法</li></ul> <blockquote><p>简单来说就是：闭包会常驻内存，增加内存使用量。</p></blockquote> <p>所以需要及时释放——</p> <p>【2.1】解决内存泄漏的方法让<strong>内部函数对象</strong>f成为垃圾对象！！</p> <div class="language-js extra-class"><pre class="language-js"><code> f <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 解放空间！</span>
</code></pre></div><p>【2.2】我们可以利用垃圾回收机制销毁内存中的闭包或者手动销毁，上面提到了手动销毁，而垃圾回收机制有如下方法——</p> <ul><li>标记清除法</li> <li>循环计数法</li></ul> <blockquote><p>自己总结</p></blockquote> <p>1.闭包是指有权访问另一个函数作用域中变量的函数。简单理解就是一个作用域可以访问另外一个函数内部的局部变量。</p> <p>2.闭包的作用是可以延长变量作用域，在函数外部可以访问函数内部的局部变量。</p> <p>3.缺点是容易造成内存泄露，闭包中的局部变量不会被回收</p> <p>GEC是全局执行上下文，在程序开始跑的时候进入执行栈。
当遇到函数的时候会有函数的执行上下文入栈，执行完则销毁。
执行上下文有两部分，一个是VO指向此作用域的储存产量的那个对象，全局的指向GO，函数的指向自己的AO。
GO和AO都是储存变量的，如果有引用就不会销毁。</p> <h3 id="_3、算法-说一下递归和迭代的区别是什么-各有什么优缺点"><a href="#_3、算法-说一下递归和迭代的区别是什么-各有什么优缺点" class="header-anchor">#</a> 3、算法：说一下递归和迭代的区别是什么，各有什么优缺点？</h3> <blockquote><p>（一）定义：</p></blockquote> <ol><li><strong>递归</strong>: 递归常被用来描述以自相似方法重复事物的过程，在数学和开发中，指的是在函数定义中使用函数自身的方法；递归实际上不断地深层调用函数，直到函数有返回才会逐层的返回，递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，因此，递归涉及到运行时的堆栈开销（参数必须压入堆栈保存，直到该层函数调用返回为止），所以有可能导致堆栈溢出的错误；但是递归编程所体现的思想正是人们追求简洁、将问题交给计算机，以及将大问题分解为相同小问题从而解决大问题的动机。递归，还有个尾调用优化，尾调用优化就是如果本次调用的返回值，是子调用的返回值的话，本次调用就可以直接出栈了，不需要进行嵌套。就可以实现栈深为1的递归调用。递归从字面可以其理解为重复“递推”和“回归”的过程（递推：层层推进，分解问题；回归：层层回归，返回较大问题的解）</li> <li><strong>迭代</strong>: 是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。迭代是顺序的，不涉及调用栈操作，前面的代码不会被后面代码影响，递归是涉及到调用栈的，遵循先入栈后结束后入栈先结束原则，前面的函数调用会阻塞，要在后面的调用返回值后才能继续执行，所以迭代的好处就是栈深小，但是代码逻辑不够清晰，递归则是嵌套调用多，栈深比较大，容易爆栈，但代码结构会比较简洁，速度的话还是迭代快。迭代大部分时候需要人为的对问题进行剖析，分析问题的规律所在，将问题转变为一次次的迭代来逼近答案。迭代不像递归那样对堆栈有一定的要求，另外一旦问题剖析完毕，就可以很容易的通过循环加以实现。迭代的效率高，但却不太容易理解，当遇到数据结构的设计时，比如图表、二叉树、网格等问题时，使用就比较困难，而是用递归就能省掉人工思考解法的过程，只需要不断的将问题分解直到返回就可以了。</li></ol> <blockquote><p>（二）同异点：</p></blockquote> <p>相同点：递归和迭代都是循环的一种。</p> <p>不同点：</p> <p>（1）程序结构不同：递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环。 其中，迭代与普通循环的区别是：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p> <p>（2）算法结束方式不同：递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。 当然很多情况都是多种循环混合采用，这要根据具体需求。</p> <p>（3）效率不同：在循环的次数较大的时候，迭代的效率明显高于递归</p> <p>（4）运行过程不同，如果是循环迭代的话，这个整个就在主函数的或者在调用函数的栈空间里面，如果是递归的话，它会不断的申请函数调用的栈空间，在计算的过程中，计算一个结果，退一层栈，递归过程，在调用的时候有可能会出现栈的溢出。</p> <p>（5）理论上递归和迭代时间复杂度方面是一样的，但实际应用中（函数调用和函数调用堆栈的开销）递归比迭代效率要低。</p> <blockquote><p>（三）优缺点</p></blockquote> <p>递归的</p> <ul><li>优点: 大问题转化为小问题，可以减少代码量，同时代码精简，可读性好。</li> <li>缺点: 递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。</li></ul> <p>迭代的</p> <ul><li>优点: 就是代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销。</li> <li>缺点: 就是代码不如递归简洁</li></ul> <blockquote><p>自己总结</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>迭代就是遍历  涉及到迭代器相关知识   递归就是函数调用本身   循环执行多次后会影响性能   有可能会爆栈  所以递归需要一个出口来控制

递归和迭代都是循环的一种，递归是重复调用函数自身实现循环，迭代是函数内部某段代码实现循环，，，递归中一定有迭代，迭代中不一定有递归
</code></pre></div><h3 id="_4、力扣101-对称二叉树-给你一个二叉树的根节点root-检查它是否轴对称。"><a href="#_4、力扣101-对称二叉树-给你一个二叉树的根节点root-检查它是否轴对称。" class="header-anchor">#</a> 4、力扣101.对称二叉树：给你一个二叉树的根节点root，检查它是否轴对称。</h3> <h4 id="_101-对称二叉树"><a href="#_101-对称二叉树" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener noreferrer">101. 对称二叉树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212111627.png" alt="image-20220212111618484"></p> <blockquote><p>这题开始想着用中序遍历获得 元素按照对称顺序排布 的数组（并把null也加进去）</p> <p>后来发现一次前/中/后序遍历无法还原一棵二叉树😢</p> <p>选对方法，找对套路很重要啊！</p></blockquote> <p>本题正解：</p> <ul><li>DFS</li></ul> <p>DFS的题目思路都很相似 完成核心思路的设计——递归式 剩下的交给递归（搜索到底）完成就ok</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先dfs深搜到最下面，验证局部对称性</span>
    <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 遍历到叶节点，返回true</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 遍历到只有一个子节点的节点，返回false</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 遍历到两个不相等的节点，返回false</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!==</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 递归比较左节点的左孩子和右节点的右孩子&amp;&amp;左节点的右孩子和右节点的左孩子</span>
        <span class="token comment">// 这一步 将递归函数dfs不断加入递归调用栈，进行局部对称性的验证</span>
        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_100-相同的树"><a href="#_100-相同的树" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener noreferrer">100. 相同的树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>做过上面的101，建议再做一下这道题，几乎一模一样的思路，但是又有一些细小的不同点，比对着理解了两题，这类“比较两棵二叉树的不同点”的问题就能轻松解决了！</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isSameTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">p<span class="token punctuation">,</span> q</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> q <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">!==</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 唯一的区别，上一题要求对称，这一题要求完全一样~所以return中的内容略有不同</span>
    <span class="token keyword">return</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span> q<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span> q<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_2022-01-13"><a href="#_2022-01-13" class="header-anchor">#</a> 2022.01.13</h2> <h3 id="_1-箭头函数与普通函数的区别"><a href="#_1-箭头函数与普通函数的区别" class="header-anchor">#</a> 1.箭头函数与普通函数的区别</h3> <blockquote><p>自己总结</p></blockquote> <h4 id="_1-写法不一样"><a href="#_1-写法不一样" class="header-anchor">#</a> 1：写法不一样</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_2-普通函数存在变量提升的现象"><a href="#_2-普通函数存在变量提升的现象" class="header-anchor">#</a> 2：普通函数存在变量提升的现象</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//普通函数</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//箭头函数</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//报错 foo is not a function</span>
<span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><h4 id="_3-箭头函数不能作为构造函数使用"><a href="#_3-箭头函数不能作为构造函数使用" class="header-anchor">#</a> 3：箭头函数不能作为构造函数使用</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">let</span> xiao_ming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xiao_ming<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">//undefined</span>
</code></pre></div><h4 id="_4-两者this的指向不同"><a href="#_4-两者this的指向不同" class="header-anchor">#</a> 4：两者this的指向不同</h4> <p>普通函数的this指向的是谁调用该函数就指向谁</p> <p>箭头函数的this指向的是在你书写代码时候的上下文环境对象的this，如果没有上下文环境对象，那么就指向最外层对象window。</p> <h4 id="_5-箭头函数的arguments指向它的父级函数所在作用域的arguments"><a href="#_5-箭头函数的arguments指向它的父级函数所在作用域的arguments" class="header-anchor">#</a> 5：箭头函数的arguments指向它的父级函数所在作用域的arguments</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
  <span class="token keyword">let</span> <span class="token function-variable function">foo1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span>

<span class="token comment">//[Arguments] { '0': 'test' }</span>
<span class="token comment">//[Arguments] { '0': 'test' }</span>
</code></pre></div><h4 id="_6-箭头函数没有new-target"><a href="#_6-箭头函数没有new-target" class="header-anchor">#</a> 6：箭头函数没有new.target</h4> <p>先说明下new.target是干嘛的，这家伙是用来检测函数是否被当做构造函数使用，他会返回一个指向构造函数的引用。</p> <p>因为箭头函数不能当做构造函数使用，自然是没有new.target的。</p> <h3 id="_2-this指向哪里"><a href="#_2-this指向哪里" class="header-anchor">#</a> 2.this指向哪⾥？</h3> <blockquote><p>自己总结</p></blockquote> <ul><li>普通函数中：this-&gt;window</li> <li>定时器中：this-&gt;window</li> <li>构造函数中：this-&gt;当前实例化的对象</li> <li>事件处理函数中：this-&gt;事件触发对象</li> <li>在 js 中一般理解就是谁调用这个 this 就指向谁</li></ul> <h3 id="_3-扩展运算符的作用及使用场景"><a href="#_3-扩展运算符的作用及使用场景" class="header-anchor">#</a> 3.扩展运算符的作用及使用场景</h3> <blockquote><p>自己总结</p></blockquote> <h4 id="将一个数组转为用逗号分隔的参数序列。"><a href="#将一个数组转为用逗号分隔的参数序列。" class="header-anchor">#</a> 将一个数组转为用逗号分隔的参数序列。</h4> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 1 2 3</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">//1 2 3 4 5</span>
</code></pre></div><h4 id="普通函数中使用"><a href="#普通函数中使用" class="header-anchor">#</a> 普通函数中使用</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> <span class="token operator">...</span>items</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>numbers<span class="token punctuation">)</span> <span class="token comment">// 3</span>
</code></pre></div><h4 id="替代-apply-方法调用函数"><a href="#替代-apply-方法调用函数" class="header-anchor">#</a> 替代 apply 方法调用函数</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES5 的写法</span>
Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// ES6 的写法</span>
Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 等同于</span>
Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="合并数组"><a href="#合并数组" class="header-anchor">#</a> 合并数组</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// ES5的合并数组</span>
arr1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr2<span class="token punctuation">,</span> arr3<span class="token punctuation">)</span>  <span class="token comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span>

<span class="token comment">// ES6的合并数组</span>
<span class="token punctuation">[</span><span class="token operator">...</span>arr1<span class="token punctuation">,</span> <span class="token operator">...</span>arr2<span class="token punctuation">,</span> <span class="token operator">...</span>arr3<span class="token punctuation">]</span>  <span class="token comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span>
</code></pre></div><h4 id="与解构赋值结合"><a href="#与解构赋值结合" class="header-anchor">#</a> 与解构赋值结合</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
first <span class="token comment">// 1</span>
rest  <span class="token comment">// [2, 3, 4, 5]</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
first <span class="token comment">// undefined</span>
rest  <span class="token comment">// []</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
first  <span class="token comment">// &quot;foo&quot;</span>
rest   <span class="token comment">// []</span>
</code></pre></div><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token operator">...</span>butLast<span class="token punctuation">,</span> last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 报错</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>middle<span class="token punctuation">,</span> last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 报错</span>
</code></pre></div><h4 id="将字符串转为数组"><a href="#将字符串转为数组" class="header-anchor">#</a> 将字符串转为数组</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>

<span class="token comment">// ES5  </span>
<span class="token keyword">var</span> arr1 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] </span>

<span class="token comment">// ES6  </span>
<span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>str<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] </span>
</code></pre></div><h4 id="实现了-iterator-接口的对象"><a href="#实现了-iterator-接口的对象" class="header-anchor">#</a> 实现了 Iterator 接口的对象</h4> <p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> domList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>domList<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_4-217-存在重复元素"><a href="#_4-217-存在重复元素" class="header-anchor">#</a> 4.<a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener noreferrer">217. 存在重复元素<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>经典的数组查重问题！</p> <ul><li>【1】利用判重API <code>indexOf</code>构建去重辅助数组</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">containsDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newArr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newArr<span class="token punctuation">.</span>length <span class="token operator">!==</span> nums<span class="token punctuation">.</span>length
<span class="token punctuation">}</span>

</code></pre></div><p>执行用时较高！想必是<code>indexOf</code>方法的锅咯~</p> <ul><li>【2】利用数据结构Set 构造只有单一元素的Set对象,判断Set对象与原数组长度是否相同</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">containsDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
  <span class="token keyword">return</span> newArr<span class="token punctuation">.</span>size <span class="token operator">!==</span> nums<span class="token punctuation">.</span>length
<span class="token punctuation">}</span>

</code></pre></div><ul><li>同理 使用哈希表记录出现的次数也可以~</li></ul> <p>这里用Set其实更好哈~主要上面刚用过 换个口儿😄</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">containsDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

</code></pre></div><p>时间复杂度O(N)</p> <p>空间复杂度O(N)</p> <blockquote><p>自己写的</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {number[]} nums
 * @return {boolean}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">containsDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>【3】排序后冒泡比较</li></ul> <p>这里可以拓展炫技手写个排序出来？😏</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">containsDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  nums<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

</code></pre></div><p>时间复杂度O(N*log~N~)</p> <p>空间复杂度O(log~N~) 在这里应当考虑排序时递归调用栈的深度。</p> <blockquote><p>V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，</p> <ul><li>数量小于10的数组使用 <code>InsertionSort</code>-插入排序</li> <li>比10大的数组则使用 <code>QuickSort</code>-快速排序</li></ul> <p>详情见<a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js" target="_blank" rel="noopener noreferrer">V8 引擎array源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 710行开始 快排在760行处</p></blockquote> <ul><li>【4】说干就干！来手写个快排！参考之前写过的一篇<a href="https://blog.csdn.net/qq_45704942/article/details/116448702?spm=1001.2014.3001.5502" target="_blank" rel="noopener noreferrer">Java题解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（写得贼详细 每一步都拆分开来说了！），这篇文章是参考的leetcode主站的一篇<a href="https://leetcode-cn.com/problems/sort-an-array/solution/dong-hua-mo-ni-yi-ge-kuai-su-pai-xu-wo-x-7n7g/" target="_blank" rel="noopener noreferrer">优秀图解 by 袁厨<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>~（好家伙连环参考）</li></ul> <p>快排分以下几步</p> <p>1.选出基准值</p> <p>2.使用<a href="https://leetcode-cn.com/problems/sort-an-array/solution/dong-hua-mo-ni-yi-ge-kuai-su-pai-xu-wo-x-7n7g/" target="_blank" rel="noopener noreferrer">填坑法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，写一个partition函数将数组分为小于基准值和大于基准值两部分</p> <p>3.递归完成快排！</p> <p>下面代码里这个注释很清楚了吧！</p> <p>另外还写了个<a href="https://leetcode-cn.com/problems/sort-an-array/solution/javascriptjava-chao-xiang-xi-ti-jie-tian-dsvc/" target="_blank" rel="noopener noreferrer">题解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 搭配图看着更舒服哈~</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">sortArray</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 调用快排方法</span>
  <span class="token keyword">return</span> nums
<span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token function-variable function">quicksort</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span> <span class="token comment">// 得到用来将数组分成两部分（左面全小于index 右面全大于index）的索引</span>
    <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 以第一轮得出的index为基准划分出左半区和右半区 对数组的左半区进行递归 将其全部变为有序</span>
    <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span> <span class="token comment">// 同理左半区</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token function-variable function">partition</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token comment">// 选定第一个元素为基准值 把它拿出来 即为“挖坑”</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 【1】 挖了坑就需要填坑~从high指针开始向左找</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      high<span class="token operator">--</span>
    <span class="token punctuation">}</span>
    arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token comment">// 一旦找到比坑对应值pivot小的 就扔到low那侧的坑里</span>
    <span class="token comment">// 【2】 同【1】从low指针开始向右找填坑值</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      low<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token comment">// 一旦找到比坑对应值pivot大的 就扔到high那侧的坑里</span>
    <span class="token comment">//（刚刚这侧有一个值去填low那侧的坑了 所以出现了一个坑位~）    }</span>
    <span class="token comment">// 经过上面【1】【2】的不断迭代 low===high 此时这个位置即为基准位置</span>
    arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot
    <span class="token keyword">return</span> low <span class="token comment">// 分区成功！返回定海神针~（此时low=high哦~）</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><blockquote><p>再拓展补充下~</p> <ul><li><p>不稳定的四种排序方法 <strong>快选希堆</strong></p></li> <li><p>最快的排序方法是<strong>归并排序</strong> 还有一个不常见的堆排序！ 时间复杂度为 n×log~n~</p> <ul><li>快速排序的平均时间复杂度是n×log~n~</li></ul> <p><img src="%E6%A0%A1%E6%8B%9B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.assets/7f79a76fa5224409bdcea8ed5cef1470tplv-k3u1fbpfcp-zoom-1.awebp" alt="img"></p></li> <li><p>归并排序和快速排序的区别：</p> <p><img src="%E6%A0%A1%E6%8B%9B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.assets/431ac187d7ac4331abc3702407c3ab16tplv-k3u1fbpfcp-zoom-1.awebp" alt="img"></p> <ul><li>归并是先拆开 从底下往上面排</li> <li>快排是每次都打乱一下 从上往下排</li></ul></li></ul></blockquote> <h2 id="_2022-01-14"><a href="#_2022-01-14" class="header-anchor">#</a> 2022.01.14</h2> <h3 id="_1-讲一下强缓存和协商缓存的区别"><a href="#_1-讲一下强缓存和协商缓存的区别" class="header-anchor">#</a> 1.讲一下强缓存和协商缓存的区别</h3> <blockquote><p>群友</p></blockquote> <ol><li>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</li></ol> <blockquote><p>强缓存策略和协商缓存策略</p></blockquote> <ul><li><p>在缓存命中时<strong>都会直接使用本地的缓存副本</strong>；</p></li> <li><p>它们缓存不命中时，都会<strong>向服务器发送请求来获取资源</strong>。在实际的缓存机制中，强缓存策略和协商缓存策略是一起<strong>合作使用</strong>的。</p> <ul><li><strong>浏览器</strong>首先会根据请求的信息判断<strong>强缓存</strong>是否命中，【1】如果命中则直接使用本地资源的副本。如果不命中则【2】根据头信息向服务器发起请求，使用协商缓存——</li> <li>【3】如果<strong>协商缓存</strong>命中的话（资源没有过期，服务器响应报文状态码为304 临时重定向），则<strong>服务器</strong>不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则服务器返回最新的资源给浏览器。</li></ul></li></ul> <h4 id="缓存技术实现"><a href="#缓存技术实现" class="header-anchor">#</a> 缓存技术实现</h4> <blockquote><p>对于一些具有重复性的HTTP请求 比如<strong>每次请求得到的数据都是一样的</strong> 我们就可以把这对<strong>请求-响应</strong>的数据都缓存在本地 那么下次就直接读取本地的数据 不必再通过网络获取服务器的响应了~</p></blockquote> <p>这样的话HTTP/1.1的性能肯定可以获得肉眼可见的提升！</p> <p>总结一下上面所说的 避免发送HTTP请求的方法 就是通过==缓存技术==来实现 HTTP设计者早在之前就考虑到了这点 因此<strong>HTTP协议的头部有不少是针对缓存的字段</strong></p> <h4 id="缓存技术实现细节"><a href="#缓存技术实现细节" class="header-anchor">#</a> 缓存技术实现细节</h4> <p>再来刨根问底一下 缓存是如何做到的呢？</p> <blockquote><p>【1】客户端会把<strong>第一次请求以及相应的数据保存在本地磁盘上</strong></p> <p>其中将请求的URL作为key 而响应作为value 两者形成映射关系 <strong>URL-&gt;响应</strong></p> <p>这样 当后续发起相同的请求时 就可以先在本地磁盘上通过key查到对应的value 也就是响应 （前提：资源没有过期）<img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212113726.png" alt="image-20210810095837315"></p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212113730.png" alt="image-20210810095923121"></p></blockquote> <h4 id="更新缓存的资源"><a href="#更新缓存的资源" class="header-anchor">#</a> 更新缓存的资源</h4> <p>看到这里 新的问题又会出现了——</p> <p>万一<strong>缓存的响应不是最新的</strong>，而客户端并不知情 那么该怎么办呢？</p> <p>这个问题HTTP的设计者也早已考虑到了~</p> <blockquote><p>服务器在发送HTTP响应时 会<strong>估算一个过期的时间</strong> 并把这个信息放到响应头部中——</p> <p>这样客户端在<strong>查看响应头部的信息时，【2】一旦发现缓存的响应是过期的，则就会重新发送网络请求</strong>。（强缓存命中则直接使用本地资源的副本。如果不命中则根据头信息向服务器发起请求，使用协商缓存，也就是接下来的【3】）</p></blockquote> <p>HTTP关于缓存说明的头部字段很多~这部分内容之后再仔细研究下 暂时不再拓展了</p> <h4 id="更新缓存资源细节"><a href="#更新缓存资源细节" class="header-anchor">#</a> 更新缓存资源细节</h4> <p>最后再来思考一个问题——</p> <blockquote><p>如果客户端从第⼀次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有 变更，还是⽼样⼦，那么你觉得还要在服务器的响应带上这个资源吗？</p> <p>很显然不带的话，可以提⾼ HTTP 协议的性能，那具体如何做到呢？</p></blockquote> <p>是啊 如果在重新发送请求的时候发现资源并没有变更 那么服务器在响应的时候应该返回什么资源呢？</p> <blockquote><p>【3】这个就需要我们在客户端重新发送请求时 <strong>在请求的 <code>Etag</code> 头部带上第一次请求的响应头部中的摘要</strong>，这个<u>摘要是唯一标识响应的资源</u>，当服务器收到请求后 会将本地资源的摘要（也就是最新的摘要） 与 请求中的摘要（缓存中的摘要）做个比较——</p> <ul><li>如果不同 说明客户端的缓存（URL-&gt;响应）已经没有价值 服务器将在响应中带上最新的资源。</li></ul> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212113707.png" alt="image-20210810101411121"></p> <ul><li>如果相同 说明客户端的缓存还是可以继续使用的 那么服务器<strong>仅返回不含有包体的 <code>304 Not Modified</code> 响应</strong> 来告诉客户端“缓存的资源仍然有效哦！” 这样可以减少响应资源在网络中传输的延时！
<ul><li>==协商缓存==</li></ul></li></ul> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212113712.png" alt="image-20210810101704953"></p></blockquote> <p>通过本个问题 - “如何避免发送HTTP请求” 对4个小点的研究</p> <p>我们发现每一个点都包含了“缓存”</p> <p>可以看出来 缓存真的是性能优化的一把万能钥匙！</p> <p>小到 CPU Cache、Page Cache、Redis Cache</p> <p>大到HTTP协议的缓存~</p> <h3 id="_2-如何解决跨越问题"><a href="#_2-如何解决跨越问题" class="header-anchor">#</a> 2.如何解决跨越问题</h3> <blockquote><p>群友答案</p></blockquote> <p>CORS跨域 JSONP  postMessage 跨域  nginx代理跨域   nodejs 中间件代理跨域  vue框架的跨域  WebSocket协议跨域 面试的时候讲自己熟悉的跨域就可以了</p> <blockquote><p>总结</p></blockquote> <p>​	1.JSONP 使用script标签向后台请求数据，只适用于get请求</p> <p>​	2.CORS是让服务器端设置Access-Control-Allow-Origin（头部字段），这样浏览器就不会报跨域错误</p> <p>​	3.反向代理，搭建一个自己的服务器，让自己的服务器请求数据，拿到数据之后再返回给我自己</p> <h3 id="_3-对事件委托的理解以及其使用场景"><a href="#_3-对事件委托的理解以及其使用场景" class="header-anchor">#</a> 3.对事件委托的理解以及其使用场景</h3> <blockquote><p>群友答案</p></blockquote> <p>事件委托的使用场景 :1.当存在多个元素可以共用同一个监听器 2.用事件委托实现动态监控</p> <blockquote><p>总结</p></blockquote> <p>事件委托的本质是利用了<strong>浏览器事件冒泡</strong>的机制.</p> <p>因为<strong>事件在冒泡过程中会上传到父节点</strong>,父节点可以通过事件对象获取到目标节点,因此可以把子节点的监听函数定义在父节点上,由父节点的监听函数统一处理多个子元素的事件,这种方式称为事件委托</p> <p>事件委托的使用场景 :</p> <p>1.当存在多个元素可以共用同一个监听器</p> <p>2.用事件委托实现动态监控</p> <h3 id="_4-算法-最大数"><a href="#_4-算法-最大数" class="header-anchor">#</a> 4 算法，最大数</h3> <blockquote><p>群友答案</p></blockquote> <ul><li><code>巧妙排序</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">largestNumber</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> sorted <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 存在[0,0] [0,0,0]这种特殊情况 会出现00这种奇怪的答案，所以要删去多余的0</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sorted<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sorted<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sorted<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
      i<span class="token operator">--</span> <span class="token comment">// 防止删除数组中某个元素之后造成的数组塌陷</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> sorted<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><blockquote><p>知识点：V8中sort函数的实现机制</p> <p><code>sort()</code> 方法用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FIn-place_algorithm" target="_blank" rel="noopener noreferrer">原地算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</p> <p>— MDN</p></blockquote> <blockquote><p>关于 <code>Array.prototype.sort()</code>  ，ES 规范并没有指定具体的算法，在 V8 引擎中，  <strong>7.0 版本之前</strong> ，数组长度小于10时， <code>Array.prototype.sort()</code> 使用的是插入排序，否则用快速排序。</p> <p>在 V8 引擎 <strong>7.0 版本之后</strong> 就舍弃了快速排序，因为它不是稳定的排序算法，在最坏情况下，时间复杂度会降级到 O(n2)。</p> <p>于是采用了一种混合排序的算法：<strong>TimSort</strong> 。</p> <p>这种功能算法最初用于Python语言中，严格地说它不属于以上10种排序算法中的任何一种，属于一种混合排序算法：</p> <p>在数据量小的子数组中使用<strong>插入排序</strong>，然后再使用<strong>归并排序</strong>将有序的子数组进行合并排序，时间复杂度为 <code>O(nlogn)</code> 。</p> <p>作者：an_371e
链接：https://www.jianshu.com/p/a557e9006186
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote> <h2 id="_2022-01-17"><a href="#_2022-01-17" class="header-anchor">#</a> 2022.01.17</h2> <h3 id="_1-解释一下javascript的同源策略"><a href="#_1-解释一下javascript的同源策略" class="header-anchor">#</a> 1.解释一下JavaScript的同源策略</h3> <p>同源策略是浏览器的一- 种安全机制，是浏览器对js脚本的一种限制， 它限制了从一个同源的文件或脚本与另个源的资源之间的交互，这里的同源指的是协议，域名，端口都一致，同源策略的目的是为了保护用户的信息安全和隔离一-些潜 在的恶意文件，限制了当前域下的js脚本不能访问其他域的cookie、1ocalstorage. indexDB、 不能访问其他域下的DOM，ajax也无法发送跨域请求</p> <h3 id="_2-如何实现异步编程"><a href="#_2-如何实现异步编程" class="header-anchor">#</a> 2.如何实现异步编程</h3> <p>回调函数、Promise、 generate函数、async await函数|</p> <p>​</p> <h3 id="_3-事件模型的三个阶段"><a href="#_3-事件模型的三个阶段" class="header-anchor">#</a> 3.事件模型的三个阶段</h3> <p>在DOM2级事件模型中一次事件分为3个阶段:捕获，目标，冒泡</p> <h3 id="_4-手写快速排序"><a href="#_4-手写快速排序" class="header-anchor">#</a> 4 手写快速排序</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">quickSort</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果是0就是return []</span>
  <span class="token keyword">const</span> <span class="token function-variable function">rec</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr
    <span class="token comment">// 分左边和右边</span>
    <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 以第一个为基准</span>
    <span class="token keyword">const</span> mid <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token comment">// 从第二个开始</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 比基准小的加入到right，比基准大的加入到left</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        left<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        right<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 组合成 left mid right 为上一次的递归使用，或者最终返回</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">rec</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> mid<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token function">rec</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">rec</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token comment">// 赋值操作</span>
  res<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token comment">// const arr = [2, 3, 1, 7, 6, 5, 4]</span>
arr<span class="token punctuation">.</span><span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>

</code></pre></div><h2 id="_2022-01-18"><a href="#_2022-01-18" class="header-anchor">#</a> 2022.01.18</h2> <h3 id="_1-cookie-sessionstorage-localstorage-的区别"><a href="#_1-cookie-sessionstorage-localstorage-的区别" class="header-anchor">#</a> 1.cookie sessionstorage localstorage 的区别</h3> <ul><li>共同点：都是保存在浏览器端，并且是同源的,都是<strong>字符串类型</strong>的键值对</li> <li>cookie数据始终在同源的http请求中携带，每次http请求都会携带cookie，cookie的数据大小不能超过4KB
<ul><li>sessionstorage和localstorage可以达到5MB</li></ul></li> <li>sessionstorage:仅在<strong>浏览器窗口关闭前有效</strong>，不能长久保存</li> <li>localstorage：数据始终有效，窗口或浏览器关闭也一直存在</li></ul> <h3 id="_2-浏览器的渲染过程"><a href="#_2-浏览器的渲染过程" class="header-anchor">#</a> 2.浏览器的渲染过程</h3> <ol><li>解析 HTML 构建DOM树</li> <li>解析CSS 构建CSSOM树</li> <li>利用上面两个树构建渲染树（渲染树的节点即为“渲染对象”）</li> <li>渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以被称作“<strong>回流</strong>”）这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“<strong>自动重排</strong>”。</li> <li>上述几步过后，布局结束；最后进行绘制，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ol> <p>记住这张图：</p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f313530303630342f313630333739373933393136352d33626635346532382d353436392d343039332d613065312d6530353639636563313330352e706e67.png" alt="img"></p> <h3 id="_3-渐进增强和优雅降级"><a href="#_3-渐进增强和优雅降级" class="header-anchor">#</a> 3.渐进增强和优雅降级</h3> <ul><li>渐进增强:是针对低版本浏览器构建页面，保证最基本的功能，然后针对高版本浏览器进行效果，交互等改进并追加功能，达到更好的用户体验</li> <li>优雅降级：一开始就构建完整功能，然后<strong>对低版本浏览器进行兼容</strong>适配</li></ul> <h3 id="_4-手写斐波那契数列"><a href="#_4-手写斐波那契数列" class="header-anchor">#</a> 4.手写斐波那契数列</h3> <ul><li><code>简单的动归解法</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>let fib = function(n) {
    let dp = [0, 1]
    for(let i = 2; i &lt;= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }
    console.log(dp)
    return dp[n]
};
</code></pre></div><ul><li><code>超简单的递归</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>let fb = function(n) {
    if (n === 0) {
        return 0
    }
    if (n === 1) {
        return 1
    }
    return fb(n - 1) + fb(n - 2)
};
</code></pre></div><ul><li>记忆化搜索提升效率</li></ul> <p><a href="https://my.oschina.net/u/4074923/blog/4274493" target="_blank" rel="noopener noreferrer">斐波那契数列 - cj-ervin的个人空间 - OSCHINA - 中文开源技术交流社区<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_2022-01-19"><a href="#_2022-01-19" class="header-anchor">#</a> 2022.01.19</h2> <h3 id="_1-字面量new出来的对象和object-create-null-创建出来的对象有什么区别"><a href="#_1-字面量new出来的对象和object-create-null-创建出来的对象有什么区别" class="header-anchor">#</a> 1.字面量new出来的对象和Object.create(null)创建出来的对象有什么区别？</h3> <blockquote><p>群友答案</p></blockquote> <ul><li>new创建出来的对象会<strong>继承Object的方法和属性</strong>，创建出来的对象的隐式原型（<strong>proto</strong>)会指向Object的显示原型；</li> <li>而Object.create(null)创建出来的对象原型为null，作为<strong>原型链的顶端</strong>，就<strong>没有继承Object的方法和属性</strong>。</li></ul> <h3 id="_2-数据类型检测的方式都有哪些"><a href="#_2-数据类型检测的方式都有哪些" class="header-anchor">#</a> 2.数据类型检测的方式都有哪些?</h3> <blockquote><p>群友答案</p></blockquote> <p><strong>（1）typeof</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// number</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// boolean</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">'str'</span><span class="token punctuation">)</span> <span class="token comment">// string</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// object</span>

</code></pre></div><p>其中<strong>数组、对象、null</strong>都会被判断为object，其他判断都正确。</p> <p><strong>（2）instanceof</strong></p> <p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'str'</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

</code></pre></div><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而<strong>不能判断基本数据类型</strong>。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p> <p><strong>（3） constructor</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Boolean<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'str'</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> String<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span> <span class="token comment">// true</span>

</code></pre></div><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constructor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Fn<span class="token punctuation">)</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span> <span class="token comment">// true</span>

</code></pre></div><p><strong>（4）Object.prototype.toString.call()</strong></p> <p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'str'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p> <p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p> <h3 id="_3-判断数组检测的方式都有哪些"><a href="#_3-判断数组检测的方式都有哪些" class="header-anchor">#</a> 3.判断数组检测的方式都有哪些?</h3> <ul><li>通过<code>Object.prototype.toString.call()</code>做判断</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'Array'</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>通过原型链做判断</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</code></pre></div><ul><li>通过ES6的Array.isArray()做判断</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Array.isArray(obj);
</code></pre></div><ul><li>通过instanceof做判断</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
</code></pre></div><ul><li>通过Array.prototype.isPrototypeOf</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre></div><h3 id="_4-new的具体操作过程"><a href="#_4-new的具体操作过程" class="header-anchor">#</a> 4.new的具体操作过程</h3> <blockquote><p>红宝书权威解释</p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212115512.awebp" alt="image.png"></p></blockquote> <p><a href="https://juejin.cn/post/7012887169878458404" target="_blank" rel="noopener noreferrer">群友帖子<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_2022-01-20"><a href="#_2022-01-20" class="header-anchor">#</a> 2022.01.20</h2> <h3 id="_1、实现一个三角形"><a href="#_1、实现一个三角形" class="header-anchor">#</a> 1、实现一个三角形</h3> <h3 id="_2、javascript为什么要进行变量提升-它导致了什么问题"><a href="#_2、javascript为什么要进行变量提升-它导致了什么问题" class="header-anchor">#</a> 2、JavaScript为什么要进行变量提升，它导致了什么问题？</h3> <h3 id="_3、实现节流函数和防抖函数"><a href="#_3、实现节流函数和防抖函数" class="header-anchor">#</a> 3、实现节流函数和防抖函数</h3> <h2 id="_2022-01-21"><a href="#_2022-01-21" class="header-anchor">#</a> 2022.01.21</h2> <h3 id="_1-http-1-0-1-1-2-0-3-0对应的改进点-2-0实现多路复用的底层原理"><a href="#_1-http-1-0-1-1-2-0-3-0对应的改进点-2-0实现多路复用的底层原理" class="header-anchor">#</a> 1.HTTP: 1.0 1.1 2.0 3.0对应的改进点，2.0实现多路复用的底层原理？</h3> <h4 id="http-1-0和-http-1-1-有以下区别"><a href="#http-1-0和-http-1-1-有以下区别" class="header-anchor">#</a> <strong>HTTP 1.0和 HTTP 1.1</strong> <strong>有以下区别</strong>：</h4> <ul><li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li> <li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li> <li>3.数据结构: Map 和 Set 的区别<strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li> <li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li> <li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li></ul> <h4 id="http-1-1-和-http-2-0-的区别"><a href="#http-1-1-和-http-2-0-的区别" class="header-anchor">#</a> HTTP 1.1 和 HTTP 2.0 的区别</h4> <ul><li><strong>二进制协议</strong>：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li> <li>**多路复用：**HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了&quot;队头堵塞&quot;【1】的问题。</li> <li>**数据流：**HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li> <li>**头信息压缩：**HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li> <li>**服务器推送：**HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul> <h4 id="http3-0的特点"><a href="#http3-0的特点" class="header-anchor">#</a> HTTP3.0的特点</h4> <p>HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。</p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212115532.webp" alt="image"></p> <ol><li>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。</li> <li>集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。</li> <li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。</li></ol> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212115536.webp" alt="image"></p> <ol start="4"><li>快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。</li></ol> <h3 id="_2-js-call、apply、bind作用和区别"><a href="#_2-js-call、apply、bind作用和区别" class="header-anchor">#</a> 2.Js:  call、apply、bind作用和区别</h3> <p>它们的作用一模一样，区别仅在于<strong>传入参数的形式的不同</strong>。</p> <ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li> <li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul> <p><strong>（1）call 函数的实现步骤：</strong></p> <ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li> <li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li> <li>处理传入的参数，截取第一个参数后的所有参数。</li> <li>将函数作为上下文对象的一个属性。</li> <li>使用上下文对象来调用这个方法，并保存返回结果。</li> <li>删除刚才新增的属性。</li> <li>返回结果。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断调用对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'type error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token comment">// 获取参数</span>
  <span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    result <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 判断 context 是否传入，如果未传入则设置为 window</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window <span class="token comment">// 将调用函数设为对象的方法</span>
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">// 调用函数</span>
  result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token comment">// 将属性删除</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>

</code></pre></div><p><strong>（2）apply 函数的实现步骤：</strong></p> <ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li> <li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li> <li>将函数作为上下文对象的一个属性。</li> <li>判断参数值是否传入</li> <li>使用上下文对象来调用这个方法，并保存返回结果。</li> <li>删除刚才新增的属性</li> <li>返回结果</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断调用对象是否为函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 判断 context 是否存在，如果未传入则为 window</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window <span class="token comment">// 将函数设为对象的方法</span>
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">// 调用方法</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token comment">// 将属性删除</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>

</code></pre></div><p><strong>（3）bind 函数的实现步骤：</strong></p> <ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li> <li>保存当前函数的引用，获取其余传入参数值。</li> <li>创建一个函数返回</li> <li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断调用对象是否为函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token comment">// 获取参数</span>
  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 根据调用方式，传入不同绑定值</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Fn</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span>
      args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="_3-数据结构-map-和-set-的区别"><a href="#_3-数据结构-map-和-set-的区别" class="header-anchor">#</a> 3.数据结构: Map 和 Set 的区别</h3> <h4 id="map"><a href="#map" class="header-anchor">#</a> Map</h4> <p><code>Map</code>对象<strong>保存键值对</strong>。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数<code>Map</code>可以接受一个数组作为参数。</p> <p><strong>Map和Object的区别</strong></p> <ul><li>一个<code>Object</code> 的键只能是字符串或者 <code>Symbols</code>，但一个<code>Map</code> 的键可以是任意值。</li> <li><code>Map</code>中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li> <li><code>Map</code>的键值对个数可以从 size 属性获取，而 <code>Object</code> 的键值对个数只能手动计算。</li> <li><code>Object</code> 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li></ul> <p><strong>Map对象的属性</strong></p> <ul><li>size：返回Map对象中所包含的键值对个数</li></ul> <p><strong>Map对象的方法</strong></p> <ul><li>set(key, val): 向Map中添加新元素</li> <li>get(key): 通过键值查找特定的数值并返回</li> <li>has(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false</li> <li>delete(key): 通过键值从Map中移除对应的数据</li> <li>clear(): 将这个Map中的所有元素删除</li></ul> <p><strong>map与其他数据结构的互相转换</strong></p> <ul><li><code>Map</code>与对象的互换</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// {a:111, b: 222}</span>

</code></pre></div><ul><li><code>JSON</code>字符串要转换成<code>Map</code>可以先利用JSON.parse()转换成数组或者对象，然后再转换即可。</li></ul> <h4 id="set"><a href="#set" class="header-anchor">#</a> Set</h4> <p><code>Set</code>对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，<strong>没有重复的值</strong>。</p> <p><code>Set</code> 本身是一个构造函数，用来生成<code>Set</code> 数据结构。<code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p> <p><strong>Set中的特殊值</strong></p> <p><code>Set</code> 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p> <ul><li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复</li> <li>undefined 与 undefined 是恒等的，所以不重复</li> <li>NaN 与 NaN 是不恒等的，但是在 Set 中认为NaN与NaN相等，所有只能存在一个，不重复。</li></ul> <p><strong>Set实例对象的属性</strong></p> <ul><li>size：返回Set实例的成员总数。</li></ul> <p><strong>Set实例对象的方法</strong></p> <ul><li><code>add(value)</code>：添加某个值，返回 Set 结构本身(可以链式调用)。</li> <li><code>delete(value)</code>：删除某个值，删除成功返回<code>true</code>，否则返回<code>false</code>。</li> <li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li> <li><code>clear()</code>：清除所有成员，没有返回值。</li></ul> <p><strong>遍历方法</strong></p> <ul><li><code>keys()</code>：返回键名的遍历器。</li> <li><code>values()</code>：返回键值的遍历器。</li> <li><code>entries()</code>：返回键值对的遍历器。</li> <li><code>forEach()</code>：使用回调函数遍历每个成员。</li></ul> <p>由于<code>Set</code>结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</p> <p><strong>Set 对象作用</strong></p> <ul><li>数组去重(利用扩展运算符)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> mySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">!</span><span class="token punctuation">[</span><span class="token operator">...</span>mySet<span class="token punctuation">]</span> <span class="token comment">// [1, 2, 3, 4]</span>

</code></pre></div><ul><li>合并两个set对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> union <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// {1, 2, 3, 4}</span>

</code></pre></div><ul><li>交集</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> intersect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> b<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {2, 3} 利用数组的filter方法</span>

</code></pre></div><ul><li>差集</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> difference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>b<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//  {1}</span>

</code></pre></div><h4 id="二者区别"><a href="#二者区别" class="header-anchor">#</a> 二者区别</h4> <p>综上所述，主要有一下几个<strong>区别</strong>：</p> <p>1.<strong>Map是键值对，Set是值的集合</strong>，当然键和值可以是任何的值；</p> <p>2.Map可以通过get方法获取值，而set不能因为它只有值；</p> <p>3.都能通过迭代器进行for...of遍历；</p> <p>4.<strong>Set的值是唯一的可以做数组去重，Map由于没有格式限制，可以做数据存储</strong></p> <p>5.map和set都是stl中的关联容器，map以键值对的形式存储，key=&gt;value组成pair，是一组映射关系。set只有值，可以认为只有一个数据，并且set中元素不可以重复且自动排序。</p> <h2 id="_2022-01-22"><a href="#_2022-01-22" class="header-anchor">#</a> 2022.01.22</h2> <h3 id="_1-javascript中对象继承的方式有哪些"><a href="#_1-javascript中对象继承的方式有哪些" class="header-anchor">#</a> 1. JavaScript中对象继承的方式有哪些？</h3> <ul><li><p>原型式继承</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 原型式继承// Object()可以理解为对传入的对象进行一个浅复制</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'szj'</span><span class="token punctuation">,</span> <span class="token literal-property property">friends</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'zy'</span><span class="token punctuation">,</span> <span class="token string">'wjr'</span><span class="token punctuation">,</span> <span class="token string">'ghk'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> me <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>
me<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'ssss'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token comment">//{ name: 'szj', friends: [ 'zy', 'wjr', 'ghk', 'ssss' ] }//{ name: 'szj', friends: [ 'zy', 'wjr', 'ghk', 'ssss' ] }</span>

</code></pre></div></li></ul></li> <li><p>寄生式继承</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 寄生继承// 像是对原型继承的另一种升级 , 采用了工厂模式的方法 增加了对象的方法</span>
<span class="token keyword">let</span> jisheng <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'sss'</span><span class="token punctuation">,</span> <span class="token literal-property property">friends</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'ss'</span><span class="token punctuation">,</span> <span class="token string">'www'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">js</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> clone <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
  clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>clone<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> clone
<span class="token punctuation">}</span>
<span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token function">js</span><span class="token punctuation">(</span>jisheng<span class="token punctuation">)</span>
m<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// sss</span>

</code></pre></div></li></ul></li> <li><p>组合继承</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 组合继承// 原型链 ＋ 盗用构造函数</span>
<span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'szj'</span><span class="token punctuation">,</span> <span class="token string">'zy'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token class-name">Super</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 盗用构造函数</span>
  <span class="token function">Super</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token comment">// 原型链继承</span>
<span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> bob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token string">'szj'</span><span class="token punctuation">)</span>
bob<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bob<span class="token punctuation">.</span>friends<span class="token punctuation">)</span> <span class="token comment">// szj// [ 'szj', 'zy' ]</span>

</code></pre></div></li></ul></li> <li><p>寄生式组合继承</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 寄生式组合继承// 最佳实践!! 相比于组合继承 减少了构造函数调用的次数</span>
<span class="token keyword">function</span> <span class="token function">Superr</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'ss'</span><span class="token punctuation">,</span> <span class="token string">'www'</span><span class="token punctuation">,</span> <span class="token string">'ppp'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token class-name">Superr</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Subb</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Superr</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">sub<span class="token punctuation">,</span> superr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prototype <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>superr<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// 别忘了原型对象的指向</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> sub
  sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype
<span class="token punctuation">}</span>
<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Subb<span class="token punctuation">,</span> Superr<span class="token punctuation">)</span>
<span class="token keyword">const</span> zy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subb</span><span class="token punctuation">(</span><span class="token string">'zy'</span><span class="token punctuation">)</span>
zy<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>zy<span class="token punctuation">.</span>friends<span class="token punctuation">)</span> <span class="token comment">// zy    // [ 'szj', 'zy' ]</span>

</code></pre></div></li></ul></li></ul> <h3 id="_2-实现异步加载方法的关键字有哪些"><a href="#_2-实现异步加载方法的关键字有哪些" class="header-anchor">#</a> 2. 实现异步加载方法的关键字有哪些？</h3> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212121035.png" alt="image.png"></p> <ul><li>defer</li> <li>async</li> <li>总结：
<ul><li>两者都是用来异步加载外部脚本的关键字</li> <li>defer 加载完成后 页面渲染后执行</li> <li>async 加载完成后 立即执行</li> <li><strong>多个 defer 按顺序依次执行</strong>  ， 多个async执行顺序不定</li></ul></li></ul> <h3 id="_3-什么是js的事件循环-事件循环机制是什么"><a href="#_3-什么是js的事件循环-事件循环机制是什么" class="header-anchor">#</a> 3. 什么是JS的事件循环 ， 事件循环机制是什么？</h3> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212121041.png" alt="image"></p> <p>如图： JS是单线程的 ， 在代码执行时，会将代码压入执行栈中保证函数的有序执行 ， 遇到异步任务会将 任务抛给webapi进行处理 ， 处理之后将回调函数推到任务队列（宏任务队列 ， 微任务队列） ， 当执行栈为空时 ， 先执行微任务队列中的函数 ， 如果需要渲染页面 ， 则会渲染页面 ， 最后执行宏任务队列中的函数。</p> <p>Event Loop 执行顺序如下所示：</p> <ul><li>首先执行同步代码，这属于宏任务</li> <li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li> <li>执行所有微任务</li> <li>当执行完所有微任务后，<strong>如有必要会渲染页面</strong></li> <li>然后开始下一轮 Event Loop，执行宏任务中的异步代码</li></ul> <p>宏任务</p> <ul><li>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li> <li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</li></ul> <h3 id="_4-leetcode-20-有效的括号"><a href="#_4-leetcode-20-有效的括号" class="header-anchor">#</a> 4 <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener noreferrer">leetcode 20 有效的括号 <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {string} s
 * @return {boolean}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">isValid</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span>length
  <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">)</span>
  map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">)</span>
  map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> stack<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_2022-01-23"><a href="#_2022-01-23" class="header-anchor">#</a> 2022.01.23</h2> <h3 id="_1-let、const、var区别"><a href="#_1-let、const、var区别" class="header-anchor">#</a> 1. let、const、var区别</h3> <blockquote><p>能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var</p></blockquote> <ul><li>作用域
<ul><li>let 、 const 为块级作用域</li> <li>var为函数作用域</li></ul></li> <li>是否可以重复声明
<ul><li>let var 可以重复声明</li> <li>const 不可以重复声明</li></ul></li> <li>变量提升
<ul><li>var 具有变量提升</li></ul></li> <li>暂时性死区
<ul><li>let 、const 具有暂时性死区 ， 未声明之后不能使用</li></ul></li> <li>给全局添加属性
<ul><li>var 可以给全局添加属性 let const 不会</li></ul></li> <li>初始值设置
<ul><li>var let 声明时可以不设置初始值</li> <li>const 必须设置初始值</li></ul></li> <li>指针的指向
<ul><li>let 可以修改指针的指向（重新赋值） ， const 不能够修改指针的指向不可以重新赋值，但是引用数据类型的属性可以改变</li></ul></li></ul> <table><thead><tr><th><strong>区别</strong></th> <th><strong>var</strong></th> <th><strong>let</strong></th> <th><strong>const</strong></th></tr></thead> <tbody><tr><td>是否有块级作用域</td> <td>×</td> <td>✔️</td> <td>✔️</td></tr> <tr><td>是否存在变量提升</td> <td>✔️</td> <td>×</td> <td>×</td></tr> <tr><td>是否添加全局属性</td> <td>✔️</td> <td>×</td> <td>×</td></tr> <tr><td>能否重复声明变量</td> <td>✔️</td> <td>×</td> <td>×</td></tr> <tr><td>是否存在暂时性死区</td> <td>×</td> <td>✔️</td> <td>✔️</td></tr> <tr><td>是否必须设置初始值</td> <td>×</td> <td>×</td> <td>✔️</td></tr> <tr><td>能否改变指针指向</td> <td>✔️</td> <td>✔️</td> <td>×</td></tr></tbody></table> <h3 id="_2-数组去重-的方法有哪些"><a href="#_2-数组去重-的方法有哪些" class="header-anchor">#</a> 2. ==数组去重==的方法有哪些？</h3> <h5 id="_1-数组元素比较型"><a href="#_1-数组元素比较型" class="header-anchor">#</a> 1. 数组元素比较型</h5> <ul><li><p>双层<code>for</code>循环</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 双层for循环// 前一个跟之后所有进行比较 ， 重复了删除掉</span>
<span class="token keyword">function</span> <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 删除后下表移动到原位置</span>
        j<span class="token operator">--</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>

</code></pre></div></li></ul></li> <li><p>排序后 相邻位置进行比较</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 排序进行后进行相邻比较</span>
<span class="token keyword">function</span> <span class="token function">sortQ</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 排序后	// 没参数 如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。</span>
  arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
      i<span class="token operator">--</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></li></ul></li></ul> <h5 id="_2-查找元素位置型"><a href="#_2-查找元素位置型" class="header-anchor">#</a> 2.查找元素位置型</h5> <ul><li><p><code>indexOf</code> 查找元素并返回其第一个索引值</p> <blockquote><p>这个方法有点秀哦！利用<code>indexOf</code> API的特性，且效率也是最佳！</p></blockquote> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>

</code></pre></div></li></ul></li> <li><p><code>findIndex</code>  返回数组中第一个满足测试函数的元素的索引</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> item <span class="token operator">===</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>

</code></pre></div></li></ul></li></ul> <h5 id="_3-查找元素存在型"><a href="#_3-查找元素存在型" class="header-anchor">#</a> 3. 查找元素存在型</h5> <ul><li><p><code>includes</code></p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 查找元素存在型</span>
<span class="token keyword">function</span> <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>

</code></pre></div></li></ul></li></ul> <h5 id="_4-利用数据结构类型"><a href="#_4-利用数据结构类型" class="header-anchor">#</a> 4. 利用数据结构类型</h5> <ul><li><p>set</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// set</span>
<span class="token keyword">function</span> <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></li></ul></li> <li><p>map</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 返回键值 Object.keys（key）</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>map<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></li></ul></li></ul> <h5 id="_5-总结"><a href="#_5-总结" class="header-anchor">#</a> 5. 总结</h5> <p>在简单的测试用例大概 2000 万条数据下，<code>indexOf</code> 的方案速度相对最快</p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212121307.awebp" alt="img"></p> <h3 id="_3-vue双向绑定的原理"><a href="#_3-vue双向绑定的原理" class="header-anchor">#</a> 3. vue双向绑定的原理</h3> <ul><li><p>Mvc 模式  到  mvvm模式 的转变</p></li> <li><p>Mvc 模式 controler 层要大量的控制dom</p></li> <li><p>Mvvm 模式 是真正做到了数据与视图的分离，  view 和 model 改变时 ， vm层自动进行数据和视图的同步</p></li> <li><p>vue.js 采用数据劫持结合发布者-订阅者模式的方式 ， 通过Object.defineProperty()来劫持各个属性的setter、getter，在数据监听时发布消息给订阅者 ， 触发响应的监听回调</p></li> <li><p>发布 订阅者模式让双向绑定更有效率（一对多）</p></li> <li><p>实现一个数据监听器 Observer</p> <ul><li>核心是 Object.defineProperty() ， 将Observe的数据对象进行递归遍历 ， 包括子属性的对象加上setter getter方法 ， 赋值时就会调用setter方法，就监听到了数据变化</li> <li>通知订阅者</li></ul></li> <li><p>实现Compile</p> <ul><li>解析模板的指令 ， 将模板中的变量替换成数据 ，</li> <li>初始化页面渲染 ，</li> <li>并绑定更新函数 ， 添加监听数据的订阅者 ， 一但数据有变化 ， 更新视图 --绑定更新函数</li></ul></li> <li><p>实现watcher （解析 compile 和 observe 的桥梁）</p> <ul><li>实例化在订阅者添加自己</li> <li>自己有一个update()方法  --添加订阅者</li> <li>待属性变动 ， 接受通知，调用自身的update() , 并触发compile中的回调 --》更新视图</li></ul></li> <li><p>整合形成一个mvvm</p></li></ul> <h3 id="_4-70-爬楼梯-力扣-leetcode-leetcode-cn-com"><a href="#_4-70-爬楼梯-力扣-leetcode-leetcode-cn-com" class="header-anchor">#</a> 4.<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer">70. 爬楼梯 - 力扣（LeetCode） (leetcode-cn.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <blockquote><p>和斐波那契数列问题异曲同工~</p> <p>很easy！</p></blockquote> <ul><li><p><strong>记忆化递归</strong></p> <blockquote><p>理解记忆化递归 为自己的面试加分！</p> <ul><li>使用数组存储中间结果；</li> <li>中间结果如果存在，则不要重复使用递归式进行计算！</li></ul></blockquote> <p>由于递归太耗时，可以用记忆化递归避免重复的计算。
<strong>解题过程：</strong>
1.先对n为0这种特殊情况进行处理，然后n为1和2时直接return即可
2.memo数组：存储中间结果，避免重复计算
3.接下来就是判断memo[n]是否存在，如果计算过即存在，直接返回，无需重复计算；若不存在，则进行递归计算，为前两个之和。
<strong>代码</strong></p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n <span class="token comment">// 记忆化递归 避免重复计算</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div><ul><li><p>经典动归问题</p> <p>分成多个子问题，爬第n阶楼梯的<strong>方法</strong>数量，等于 2 部分之和</p> <p>​	<strong>爬上 n-1 阶楼梯的方法数量</strong></p> <p>​	<strong>爬上 n-2 阶楼梯的方法数量</strong></p> <div class="language- extra-class"><pre class="language-text"><code>动态规划的转移方程为：dp[i] = dp[i - 1] + dp[i - 2];
</code></pre></div><p>简单地使用动归求解（这里没必要使用递归这种时间复杂度较高的方法，除非用了记忆化递归~）</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
  dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div><p>时间复杂度与空间复杂度都为O(N)</p> <ul><li>使用滚动数组（<strong>空间复杂度为1</strong>）实现动态规划（而不是使用<strong>空间复杂度为N</strong>的递归）
<ul><li>这也是官方题解的第一种方法（其他数学方法我退缩了XD）</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    q <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    r <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 初始化dp[0] dp[1] dp[2]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 利用滚动数组达到O(1)空间复杂度的动归</span>
    p <span class="token operator">=</span> q
    q <span class="token operator">=</span> r
    r <span class="token operator">=</span> p <span class="token operator">+</span> q
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> r
<span class="token punctuation">}</span>

</code></pre></div><blockquote><p>自己写的</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n
  prev2 <span class="token operator">=</span> <span class="token number">1</span>
  prev1 <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> prev1 <span class="token operator">+</span> prev2
    prev2 <span class="token operator">=</span> prev1
    prev1 <span class="token operator">=</span> temp
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> prev1
<span class="token punctuation">}</span>

</code></pre></div><h2 id="_2022-01-24"><a href="#_2022-01-24" class="header-anchor">#</a> 2022.01.24</h2> <h3 id="_1-字面量创建对象和-new-创建对象有什么区别"><a href="#_1-字面量创建对象和-new-创建对象有什么区别" class="header-anchor">#</a> 1.字面量创建对象和 new 创建对象有什么区别，</h3> <ul><li>字面量 <code>let obj = {}</code> ：
<ul><li>创建对象更简单</li> <li>方便阅读</li> <li>不需要作用域解析</li> <li>速度更快</li></ul></li></ul> <h3 id="_1-new-内部都实现了什么-手写一个-new"><a href="#_1-new-内部都实现了什么-手写一个-new" class="header-anchor">#</a> 1‘.new 内部都实现了什么， 手写一个 new</h3> <blockquote><p>红宝书权威解释</p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212121954.awebp" alt="image.png"></p></blockquote> <p>更细致的内容之前我有总结过一篇，相当于是手写<code>new Object</code>吧——</p> <p><a href="https://juejin.cn/post/7012887169878458404" target="_blank" rel="noopener noreferrer">JS小知识 new关键字都做了什么？ - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>【1】在内存中创建一个新对象</li> <li>【2】使新对象的<code>__proto__</code>指向原函数的 prototype</li> <li>【3】改变 this 指向（指向新的 obj）</li> <li>【4】执行构造函数，给新对象添加属性</li> <li>【5】执行结果保存起来作为 result 并判断执行函数的结果是不是 null 或 Undefined
<ul><li>如果是则返回之前的新对象，</li> <li>如果不是则返回 result</li></ul></li></ul> <p>手写result</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 创建一个空对象</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> fn<span class="token punctuation">.</span>prototype <span class="token comment">// 使空对象的隐式原型指向原函数的显式原型</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token comment">// this 指向 obj</span>
  <span class="token keyword">return</span> result <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> result <span class="token operator">:</span> obj <span class="token comment">// 返回创建的对象</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="_2-和-有什么区别"><a href="#_2-和-有什么区别" class="header-anchor">#</a> 2.<code>==</code>和<code>===</code>有什么区别</h3> <ul><li><p>===是严格意义上的相等，会比较两边的数据类型和值大小 数据类型不同返回 false 数据类型相同，但值大小不同，返回 false</p></li> <li><p>==是非严格意义上的相等， 两边类型相同，比较大小 两边类型不同，根据下方的规则，再进一步进行比较。</p> <ul><li><p>Null == Undefined -&gt;true</p></li> <li><p><strong>String</strong> == Number -&gt;先将 String <strong>转为 Number</strong>，再比较大小</p></li> <li><p><strong>Boolean</strong> == Number -&gt;现将 Boolean <strong>转为 Number</strong>，再进行比较</p></li> <li><p><strong>Object</strong> == String，Number，Symbol -&gt; Object <strong>转化为原始类型</strong></p> <ul><li><h2 id="对象的强制类型转换流程总结"><a href="#对象的强制类型转换流程总结" class="header-anchor">#</a> 对象的强制类型转换流程总结</h2> <p>【1】调用valueOf()方法,是原始值类型就返回,不是就继续下一步</p> <p>【2】调用toString()方式,是原始值类型就返回,不是就继续下一步</p> <p>【3】调用Number,是原始值就返回,不是就报类型错误(也只有undefined大神会这样了😂</p> <p>作者：敲代码的小提琴手  链接：https://juejin.cn/post/7022837573059870727  来源：稀土掘金</p></li></ul></li></ul></li></ul> <blockquote><p>可以看看’敲代码的小提琴手群友‘之前总结的一篇隐式类型转换的文章</p> <p><a href="https://juejin.cn/post/7022837573059870727" target="_blank" rel="noopener noreferrer">由一道面试题引入的对JavaScript隐式转换的学习 - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>红宝书这里的内容</p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212122109.png" alt="image-20220124235359385"></p></blockquote></blockquote> <h3 id="_3-在-js-中为什么-0-2-0-1-0-3"><a href="#_3-在-js-中为什么-0-2-0-1-0-3" class="header-anchor">#</a> 3.在 JS 中为什么 0.2+0.1&gt;0.3?</h3> <p>因为<strong>在 JS 中，浮点数是使用 64 位固定长度来表示的</strong>，其中——</p> <ul><li>1 位表示符号位</li> <li>11 位 用来表示指数位</li> <li>剩下的 <strong>52 位尾数位</strong>。</li></ul> <p>由于只有 52 位表示尾数位。 而 0.1 转为二进制是一个无限循环数 0.0001100110011001100......(1100 循环)</p> <blockquote><p>小数的十进制转二进制方法：</p> <p>https://jingyan.baidu.com/article/425e69e6e93ca9be15fc1626.html 注意：小数的十进制转二进制的方法是和整数不一样的</p></blockquote> <p>由于只能存储 52 位尾数位，所以会出现<strong>精度缺失</strong>——</p> <p>比如：<strong>把0.1 存到内存中，再取出来转换成十进制就不是原来的 0.1 了</strong>，就变成了 0.100000000000000005551115123126</p> <p>而为什么 02+0.1 是因为</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 0.1 和 0.2 都转化成二进制后再进行运算 0.00011001100110011001100110011001100110011001100110011010(0.1) + 0.0011001100110011001100110011001100110011001100110011010(0.2) = 0.0100110011001100110011001100110011001100110011001100111 // 结果转成十进制正好是 0.30000000000000004</span>
</code></pre></div><h3 id="_4-那为什么-0-2-0-3-0-5-呢"><a href="#_4-那为什么-0-2-0-3-0-5-呢" class="header-anchor">#</a> 4.那为什么 0.2+0.3=0.5 呢?</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 0.2 和 0.3 都转化为二进制后再进行计算 0.001100110011001100110011001100110011001100110011001101 + 0.0100110011001100110011001100110011001100110011001101 = 0.10000000000000000000000000000000000000000000000000001 //尾数为大于 52 位 // 而实际取值只取 52 位尾数位，就变成了0.1000000000000000000000000000000000000000000000000000 </span>
</code></pre></div><p><code>0.2转化为二进制</code>+<code>0.3转换为二进制</code> 的结果恰巧前 52 位尾数都是 0，截取后恰好是 0.1000000000000000000000000000000000000000000000000000=<strong>0.1(2)</strong> 也就是 0.5(10)</p> <h3 id="_5-为什么-console-log-0-1-打印得到-0-1-呢"><a href="#_5-为什么-console-log-0-1-打印得到-0-1-呢" class="header-anchor">#</a> 5.为什么 console.log(0.1) 打印得到 0.1 呢</h3> <blockquote><p>那既然 0.1 不是 0.1 了，为什么 console.log(0.1) 打印得到 0.1 呢?</p></blockquote> <p>在 console.log 的时候会——</p> <ul><li>将二进制转换为十进制</li> <li>再将十进制转为字符串的形式</li></ul> <p>在转 换的过程中发生了取近似值，所以打印出来的是一个近似值的<strong>字符串</strong></p> <h2 id="_2022-01-25"><a href="#_2022-01-25" class="header-anchor">#</a> 2022.01.25</h2> <h3 id="_1、-三栏布局-有多少种-思路和代码"><a href="#_1、-三栏布局-有多少种-思路和代码" class="header-anchor">#</a> 1、==三栏布局==，有多少种？思路和代码</h3> <blockquote><p>重点是 圣杯布局 两翼布局</p></blockquote> <p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p> <ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的 margin 的值。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.center</span> <span class="token punctuation">{</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><ul><li>利用 flex 布局，左右两栏设置固定大小，中间一栏设置为 flex:1。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.center</span> <span class="token punctuation">{</span>
  <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的 margin 值，注意这种方式**，中间一栏必须放到最后：**</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.center</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><ul><li>==圣杯布局==，利用<strong>浮动和负边距</strong>来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">padding-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">padding-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.center</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><ul><li>==双飞翼布局==，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 <strong>margin</strong> 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过<strong>浮动和外边距负值</strong>来实现的。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.wrapper</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.center</span> <span class="token punctuation">{</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="_2、css中定位有多少个值-每个值有什么特点"><a href="#_2、css中定位有多少个值-每个值有什么特点" class="header-anchor">#</a> 2、css中定位有多少个值，每个值有什么特点</h3> <p>position 有以下属性值：</p> <table><thead><tr><th>属性值</th> <th>概述</th></tr></thead> <tbody><tr><td>absolute</td> <td>生成绝对定位的元素，相对于 static 定位以外的一个父元素进行定位。元素的位置通过 left、top、right、bottom 属性进行规定。<strong>元素会被移除文档流</strong></td></tr> <tr><td>relative</td> <td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过 left、top、right、bottom 属性进行规定。<strong>元素会被移除文档流</strong></td></tr> <tr><td>fixed</td> <td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr> <tr><td>static</td> <td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr> <tr><td>inherit</td> <td>规定从父元素继承 position 属性的值</td></tr></tbody></table> <p>前面三者的定位方式如下：</p> <ul><li><strong>relative：<strong>元素的定位永远是</strong>相对于元素自身</strong>位置的，和其他元素没关系，也不会影响其他元素。</li></ul> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212122530.png" alt="image-20220212122529012"></p> <p><strong>fixed：<strong>元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它</strong>具有破坏性，会导致其他元素位置的变化</strong>(没脱离文档流还随心随遇地放置在某个位置！)。</p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212122542.png" alt="image-20220212122540631"></p> <p><strong>absolute：<strong>元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是</strong>浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位</strong>。如下两个图所示：</p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212122614.png" alt="image-20220212122613657"></p> <blockquote><p>这里真是学习到了啊！</p></blockquote> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212122625.png" alt="image-20220212122624587"></p> <h3 id="_3、对bfc的理解-如何创建bfc"><a href="#_3、对bfc的理解-如何创建bfc" class="header-anchor">#</a> 3、对BFC的理解，如何创建BFC</h3> <ul><li>Block formatting contexts（块级格式化上下文）：首先 BFC 是一个<strong>独立的布局环境</strong>，BFC 中<strong>元素的布局</strong>是<strong>不受外界影响</strong>的。
<ul><li>本质上是指 <strong>盒子内部的元素不会影响外部元素</strong>的一个布局</li></ul></li> <li>如何创建一个 BFC
<ul><li><strong>float</strong> 的值不为 none</li> <li><strong>position</strong> 的值不为 static 或者 relative</li> <li><strong>display</strong> 的值为 table-cell、table-caption、inline-block、flex、inline-flex 中的一个</li> <li><strong>overflow</strong> 的值不为 visible</li></ul></li> <li>BFC 的使用场景
<ul><li>使用 BFC 来<strong>防止外边距折叠</strong></li> <li>使用 BFC 来包含浮动，<strong>解决容器高度塌陷</strong>的问题</li> <li>使用 BFC 来<strong>防止文字环绕</strong></li> <li>在多列布局中使用 BFC，解决最后一列被挤到下一行的问题</li></ul></li></ul> <h3 id="_4、给定一个由-整数-组成的-非空-数组所表示的非负整数-在该数的基础上加一。"><a href="#_4、给定一个由-整数-组成的-非空-数组所表示的非负整数-在该数的基础上加一。" class="header-anchor">#</a> 4、给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</h3> <blockquote><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
输入：digits = [1,2,3]
输出：[1,2,4]</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">plusOne</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">digits</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> n <span class="token operator">=</span> digits<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span>
    digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">10</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> digits <span class="token comment">// 这一位没有进位就可以直接返回结果了~</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  digits<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 在最高位前面还要再进一位~</span>
  <span class="token keyword">return</span> digits
<span class="token punctuation">}</span>

</code></pre></div><h2 id="_2022-01-26"><a href="#_2022-01-26" class="header-anchor">#</a> 2022.01.26</h2> <h3 id="_1-你了解cdn吗-说一下cdn"><a href="#_1-你了解cdn吗-说一下cdn" class="header-anchor">#</a> 1.你了解cdn吗？说一下cdn</h3> <p>CDN也叫内容分发网络技术 ， 目的是为了提高传输内容的传输速度和稳定性，避开网络上的拥塞和不稳定的节点 ， 寻找最近的网络节点获取资源</p> <p>cdn上的内容分为静态和动态内容</p> <ul><li>静态：提前备份到cdn服务器</li> <li>动态：可能会在cdn服务器实现一些接口</li></ul> <p>如何转发：任播 -- 服务器对外拥有一个相同的ip地址 ， 请求会被距离最近的cdn服务器接受</p> <h3 id="_2-https的加密策略"><a href="#_2-https的加密策略" class="header-anchor">#</a> 2.Https的加密策略</h3> <blockquote><p>我也很喜欢看技术蛋老师的视频👇哈哈</p></blockquote> <p>https 分为三种加密加密算法</p> <ul><li>摘要算法 ： 输入一系列子串 输入长度一定 ， 常见的MD5</li> <li>非对称加密：公钥加密 私钥解密 （公钥会传输 私钥不会传输）</li> <li>对称加密：用同一个密钥加密 并且解密 异或的思想</li></ul> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212123018.awebp" alt="1418a9c3-66d8-43da-b53c-c3ecce2c96d8.png"> 拓展：</p> <p>https的传输过程（4次握手）</p> <ul><li>客 ： 发送协议的版本 可以支持的加密算法 以及一个随机数</li> <li>服 ： 确定加密算法 ， 发送公钥 ， 发送数字证书 以及一个随机数</li> <li>客 ： 将公钥加密后的随机数发送</li> <li>服 ： 将随机数用私钥解密</li> <li>至此 ， 将 第一随机数 第二随机数 加公钥加密后的随机数 生成 会话密钥 （对称加密）</li></ul> <h3 id="_3-js如何进行垃圾回收的-如果回收出现循环引用会导致什么"><a href="#_3-js如何进行垃圾回收的-如果回收出现循环引用会导致什么" class="header-anchor">#</a> 3.JS如何进行垃圾回收的？如果回收出现循环引用会导致什么？</h3> <p>垃圾回收的策略</p> <ul><li><p>标记清理</p> <ul><li>将内存中的所有变量或者函数都进行标记 ， 调用后去除标记 ， 一段时间后 ， 剩下还有标记的变量就会被回收</li></ul></li> <li><p>引用计数</p> <ul><li>跟踪每一个值被引用的次数 ， 赋值加一 被覆盖减一 当为零的时候可以清理</li></ul></li> <li><p>循环引用</p> <ul><li><p>当出现两个值相互引用的现象 ， 利用引用计数进行垃圾回收 ， 会导致循环引用 ， 永远不会释放 ， 因此得手动解除引用</p> <ul><li><p>例如</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code>obj1<span class="token punctuation">.</span>a <span class="token operator">=</span> obj2
obj2<span class="token punctuation">.</span>a <span class="token operator">=</span> obj1
<span class="token comment">//引用次数都为2</span>

<span class="token comment">// 手动解除引用</span>
obj1<span class="token punctuation">.</span>a <span class="token operator">=</span>  <span class="token keyword">null</span> obj2<span class="token punctuation">.</span>a <span class="token operator">=</span>  <span class="token keyword">null</span>
</code></pre></div></li></ul></li></ul></li></ul> <h3 id="_4-vue中组件间传值有哪些方法呢"><a href="#_4-vue中组件间传值有哪些方法呢" class="header-anchor">#</a> 4.Vue中组件间传值有哪些方法呢？</h3> <blockquote><p><a href="https://juejin.cn/post/7056032803531522078#heading-33" target="_blank" rel="noopener noreferrer">每日一题 点滴进步~ - 掘金 (juejin.cn)(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Vue我就不做拓展了 直接看这里就好——</p> <ul><li>父子组件
<ul><li>父组件传子组件
<ul><li>props</li></ul></li> <li>子组件向父组件传值
<ul><li>$emit()</li> <li>子组件中定义一个方法 <code>this.$eimt('父组件中的函数名' ， 传的值的名字)</code></li> <li>父组件中接受 @子组件中定义的名字 = ‘’函数名称‘ 直接以参数的形式接受</li></ul></li></ul></li></ul> <p>等,,,</p> <blockquote><p>我之前短暂用过一段时间的Vue 父子组件传值就都用的这个~</p></blockquote></blockquote> <h3 id="_5-算法题-最大回文子串-opens-new-window"><a href="#_5-算法题-最大回文子串-opens-new-window" class="header-anchor">#</a> 5.算法题 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener noreferrer">最大回文子串(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <ul><li><code>动态规划</code></li></ul> <p>贼经典的一题~</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {string} s
 * @return {string}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">longestPalindrome</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s
  <span class="token keyword">let</span> maxLength <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">let</span> leftStart <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">const</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">===</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>maxLength <span class="token operator">&lt;</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        maxLength <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span>
        leftStart <span class="token operator">=</span> left
      <span class="token punctuation">}</span>
      left<span class="token operator">--</span>
      right<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">test</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>leftStart<span class="token punctuation">,</span> leftStart <span class="token operator">+</span> maxLength<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_2022-01-27"><a href="#_2022-01-27" class="header-anchor">#</a> 2022.01.27</h2> <h3 id="_1-如何判断两个链表是否相交"><a href="#_1-如何判断两个链表是否相交" class="header-anchor">#</a> 1.如何判断两个链表是否相交?</h3> <h4 id="面试题-02-07-链表相交-opens-new-window"><a href="#面试题-02-07-链表相交-opens-new-window" class="header-anchor">#</a> <a href="https://fangzhousu.github.io/frontend-knowledge-base/study-everyday/22-1-study.html#%E9%9D%A2%E8%AF%95%E9%A2%98-02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener noreferrer">面试题 02.07. 链表相交(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/solution/js-shuang-zhi-zhen-ni-zou-guo-wo-lai-shi-kqn1/" target="_blank" rel="noopener noreferrer">【JS 双指针】你走过我 来时的路✨ - 链表相交 - 力扣（LeetCode） (leetcode-cn.com)(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">getIntersectionNode</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">headA<span class="token punctuation">,</span> headB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> headA<span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> headB<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> b <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>a <span class="token operator">!==</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
        a <span class="token operator">=</span> a<span class="token operator">===</span><span class="token keyword">null</span> <span class="token operator">?</span> headB <span class="token operator">:</span> a<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        b <span class="token operator">=</span> b<span class="token operator">===</span><span class="token keyword">null</span> <span class="token operator">?</span> headA <span class="token operator">:</span> b<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_2-对vue的响应式原理有了解么-可以简单的说一下么"><a href="#_2-对vue的响应式原理有了解么-可以简单的说一下么" class="header-anchor">#</a> 2.对vue的响应式原理有了解么，可以简单的说一下么？</h3> <blockquote><p>Vue面试题我真顶不住啊朋友，回头再碰到Vue的面试题我就自己再找一个React的替换上好了~</p> <p>不过这题我在字节二面被问到过，当时很尴尬地不会~（当然现在还是不会，，）</p></blockquote> <p>整体思路是数据劫持+观察者模式</p> <p>对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。</p> <p>相关代码如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token comment">// 观测值</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对象上的所有属性依次进行观测</span>
    <span class="token keyword">let</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> value <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归关键</span>
  <span class="token comment">// --如果value还是一个对象会继续走一遍odefineReactive 层层遍历一直到value不是对象才停止</span>
  <span class="token comment">//   思考？如果Vue数据嵌套层级过深 &gt;&gt;性能会受影响</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;获取值&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">//需要做依赖收集过程 这里代码没写出来</span>
      <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;设置值&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//需要做派发更新过程 这里代码没写出来</span>
      value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果传过来的是对象或者数组 进行属性劫持</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;[object Object]&quot;</span> <span class="token operator">||</span>
    Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>响应式数据原理详解 <a href="https://juejin.cn/post/6935344605424517128" target="_blank" rel="noopener noreferrer">传送门(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>作者：sword__song 链接：https://juejin.cn/post/7056032803531522078</p></blockquote> <h3 id="_3-【2】cookie是为了解决什么问题-session-localstorage-sessionstorage-这三者的区别是啥呢"><a href="#_3-【2】cookie是为了解决什么问题-session-localstorage-sessionstorage-这三者的区别是啥呢" class="header-anchor">#</a> 3.【2】cookie是为了解决什么问题，session, localStorage, sessionStorage，这三者的区别是啥呢？</h3> <blockquote><p>【2】代表第二次出现的题目，高频程度可见一斑咯~</p> <p>这题又出现了一遍~再复习一下</p></blockquote> <ul><li>cookie （服务器设置 ， <strong>客户端储存</strong> ， 同源请求携带） 常用来识别用户 ， 与session一起跟踪用户的状态。 最多储存4k</li> <li>session <strong>保存在服务端</strong> ， 用来跟踪用户的状态 ， 与cookie一起使用</li> <li>sessionStorage : HTML5 提供的一种<strong>浏览器本地存储</strong>的方法 ， 类似于session , 代表了一次会话所保存的数据 ， 页面关闭后失效</li> <li>loaclStorage：HTML5 提供的一种<strong>浏览器本地存储</strong>的方法 ， 保存在本地 ， 不删除就会永久的储存。</li></ul> <h3 id="_4-给你一棵树-树上的每条边权值都是1-求树上两个节点的距离-使得路径最大"><a href="#_4-给你一棵树-树上的每条边权值都是1-求树上两个节点的距离-使得路径最大" class="header-anchor">#</a> 4.给你一棵树，树上的每条边权值都是1，求树上两个节点的距离，使得路径最大</h3> <blockquote><p>额今天怎么两道力扣，</p></blockquote> <h4 id="_543-二叉树的直径-opens-new-window"><a href="#_543-二叉树的直径-opens-new-window" class="header-anchor">#</a> <a href="https://fangzhousu.github.io/frontend-knowledge-base/study-everyday/22-1-study.html#_543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener noreferrer">543. 二叉树的直径(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <ul><li><code>经典的‘求二叉树深度’的一个小变式</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">diameterOfBinaryTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> maxGap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> leftDepth <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rightDepth <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 与求深度那题的唯一区别——时刻计算直径~</span>
    maxGap <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxGap<span class="token punctuation">,</span> leftDepth <span class="token operator">+</span> rightDepth<span class="token punctuation">)</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
  <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> maxGap<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="剑指-offer-55-i-二叉树的深度-opens-new-window"><a href="#剑指-offer-55-i-二叉树的深度-opens-new-window" class="header-anchor">#</a> <a href="https://fangzhousu.github.io/frontend-knowledge-base/study-everyday/22-1-study.html#%E5%89%91%E6%8C%87-offer-55-i-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 55 - I. 二叉树的深度(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <ul><li><code>异曲同工的求深度</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> maxDepth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 用于记录最大深度</span>
  <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// “递”完了，每往上“归”一层，深度都加1咯~</span>
    <span class="token keyword">let</span> leftDepth <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rightDepth <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新深度~</span>
    maxDepth <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> maxDepth<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
  <span class="token keyword">return</span> maxDepth<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_2022-01-28"><a href="#_2022-01-28" class="header-anchor">#</a> 2022.01.28</h2> <h3 id="_1-力扣3-无重复字符的最长子串"><a href="#_1-力扣3-无重复字符的最长子串" class="header-anchor">#</a> 1.力扣3 无重复字符的最长子串</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {string} s
 * @return {number}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">lengthOfLongestSubstring</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    maxLength <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
      maxLength <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxLength<span class="token punctuation">,</span> set<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      set<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> maxLength
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-css优先级是怎么计算的"><a href="#_2-css优先级是怎么计算的" class="header-anchor">#</a> 2.css优先级是怎么计算的</h3> <ul><li><p>css优先级是通过<strong>权重计算</strong>得到的（256进制~不过这个倒是了解即可）</p></li> <li><table><thead><tr><th>选择器</th> <th>权重</th></tr></thead> <tbody><tr><td>内联样式</td> <td>1000</td></tr> <tr><td>id选择器</td> <td>100</td></tr> <tr><td>类选择器、属性选择器、伪类选择器</td> <td>10</td></tr> <tr><td>标签选择器、伪元素选择器</td> <td>1</td></tr></tbody></table></li> <li><p>另外 ！inportant 优先级最高！！</p></li></ul> <h3 id="_3-typeof和instanceof的区别"><a href="#_3-typeof和instanceof的区别" class="header-anchor">#</a> 3.typeof和instanceof的区别</h3> <p>相同点：两者都是操作符 用来判断类型</p> <p>不同点</p> <ul><li><p>typeof： string number symbol bigInt boolean function object ， 可以判断七种类型 只能判断对象 ， 无法判断哪种对象</p> <blockquote><p>也就是只能判断出来基本数据类型~</p></blockquote></li> <li><p>instanceof : 可以判断 是哪种<strong>object</strong> 但是不能判断 原始数据类型</p></li></ul> <h3 id="_4-v-if和v-show区别"><a href="#_4-v-if和v-show区别" class="header-anchor">#</a> 4.v-if和v-show区别</h3> <p><strong>原理</strong>：v-if 是利用动态的向DOM树内添加或者删除DOM ， v-show 是通过设置DOM元素的display属性控制显隐</p> <p><strong>编译过程</strong>：v-if 切换有一个局部编译/卸载的过程 ， 切换过程中合适的销毁和重建内部的事件监听和子组件 ， v-show只是进行一个css样式的切换</p> <p><strong>编译条件</strong>：v-if 是惰性的 ， 当初是条件为假 ， 不会进行一个编译 ， 只有到条件为真的时候才开始真正的编译 ， v-show 无论条件是否为真都会进行一个编译</p> <p><strong>性能消耗</strong>：v-if 涉及到编译卸载的过程 比较高的切换消耗， v-show 有比较高的初始渲染消耗</p> <p><strong>使用场景</strong>：频繁切换用v-show ，条件不大可能改变用v-if</p> <blockquote><p>作者：sword__song 链接：https://juejin.cn/post/7056032803531522078</p></blockquote> <h2 id="_2022-01-29"><a href="#_2022-01-29" class="header-anchor">#</a> 2022.01.29</h2> <h3 id="_1-null和undefined的区别"><a href="#_1-null和undefined的区别" class="header-anchor">#</a> 1. null和undefined的区别</h3> <blockquote><p>一张 形象的图~</p></blockquote> <ul><li>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。
<ul><li>undefined 代表的含义是**未定义 **常常是变量声明并没有赋值</li> <li>null 代表的含义是<strong>空对象</strong> 常用来赋值给一个可能返回对象的变量/销毁无用的对象</li></ul></li> <li>一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</li> <li>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</li></ul> <h3 id="_2-【2】判断this指向的几种方法"><a href="#_2-【2】判断this指向的几种方法" class="header-anchor">#</a> 2. 【2】判断this指向的几种方法</h3> <blockquote><p>其实this指向的问题情况并不多，但是它在不同的执行条件下可能会绑定（指向）不同的对象，如果想要再深入了解，可以看一下coderwhy的<a href="https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA" target="_blank" rel="noopener noreferrer">这篇文章(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <ul><li><blockquote><p>在 js 中一般理解就是<strong>谁调用这个 this 就指向谁</strong></p></blockquote></li> <li><p>普通函数中：this-&gt;window</p></li> <li><p>定时器中：this-&gt;window</p></li> <li><p>构造函数中：this-&gt;当前实例化的对象</p></li> <li><p>事件处理函数中：this-&gt;事件触发对象</p></li> <li><p>call、apply、bind this-&gt;指定this</p> <ul><li>这里存疑~</li></ul></li></ul> <p>根据箭头函数与否&amp;构造函数划分——</p> <ul><li>箭头函数
<ul><li>this指向为<strong>箭头函数外部的执行上下文</strong></li></ul></li> <li>非箭头函数
<ul><li>this指向<strong>该函数运行时的</strong>函数的<strong>执行上下文</strong></li></ul></li> <li>构造函数
<ul><li>this指向（构造的）新（实例）对象</li></ul></li></ul> <h3 id="_3-vue-react中key的作用-为什么不建议用index作为key"><a href="#_3-vue-react中key的作用-为什么不建议用index作为key" class="header-anchor">#</a> 3. vue/React中key的作用，为什么不建议用index作为key</h3> <blockquote><p>官方文档中的阐述：</p> <p><a href="https://react.docschina.org/docs/lists-and-keys.html#keys" target="_blank" rel="noopener noreferrer">列表 &amp; Key – React (docschina.org)(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> todoItems <span class="token operator">=</span> todos<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">todo</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>todo<span class="token punctuation">.</span>id<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">    
	</span><span class="token punctuation">{</span>todo<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> todoItems <span class="token operator">=</span> todos<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">todo<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token comment">// Only do this if items have no stable IDs </span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">    
	</span><span class="token punctuation">{</span>todo<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会<strong>导致性能变差</strong>，还可能引起<strong>组件状态的问题</strong>。可以看看 Robin Pokorny 的<a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" target="_blank" rel="noopener noreferrer">深度解析使用索引作为 key 的负面影响 (opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>这一篇文章。如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。</p> <p>要是你有兴趣了解更多的话，这里有一篇文章<a href="https://react.docschina.org/docs/reconciliation.html#recursing-on-children" target="_blank" rel="noopener noreferrer">深入解析为什么 key 是必须的 (opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>可以参考。</p> <blockquote><p>另外推荐这篇讲述diff算法与虚拟DOM渲染的文章——<a href="https://juejin.cn/post/6994959998283907102?share_token=8eaee3de-87a2-4aea-961f-0c8522270c5b" target="_blank" rel="noopener noreferrer">15张图，20分钟吃透Diff算法核心原理，我说的！！！ (opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>对下面👇的内容讲得比较通俗易懂且深入原理~</p></blockquote> <blockquote><p>在子元素列表末尾新增元素时，更新开销比较小。比如：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">first</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">second</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">first</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">second</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">third</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>React 会先匹配两个 <code>&lt;li&gt;first&lt;/li&gt;</code> 对应的树，然后匹配第二个元素 <code>&lt;li&gt;second&lt;/li&gt;</code> 对应的树，最后插入第三个元素的 <code>&lt;li&gt;third&lt;/li&gt;</code> 树。</p> <p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Duke</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Villanova</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Connecticut</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Duke</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Villanova</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>React 并不会意识到应该保留 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code>，而是会重建每一个子元素。这种情况会带来性能问题。</p></blockquote> <p>为了解决上述问题，React 引入了 <code>key</code> 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 <code>key</code> 之后，使得树的转换效率得以提高：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2015<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Duke</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2016<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Villanova</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2014<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Connecticut</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2015<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Duke</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2016<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Villanova</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>现在 React 知道只有带着 <code>'2014'</code> key 的元素是新元素，带着 <code>'2015'</code> 以及 <code>'2016'</code> key 的元素仅仅移动了。</p> <p>实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>id<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。</p></blockquote> <blockquote><p>最后，你也可以使用元素在数组中的下标<strong>index</strong>作为 key。这个策略在元素不进行重新排序时比较合适，如果有<strong>顺序修改</strong>，diff 就会变慢。</p> <p>当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是<strong>基于它们的 key 来决定是否更新以及复用</strong>（这是根据Diff算法做出的决定），如果 key 是一个下标，那么<strong>修改顺序时会修改当前的 key</strong>，导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动。</p> <blockquote><p>上面是官方文档中的阐述，但是我们不鼓励使用indx作为key，正如官方文档最后一句说的，如果元素的顺序有变，则<strong>根据Diff算法判断到的“变动的虚拟DOM节点”是有误的</strong>！ 需要重绘一大片区域的节点！—— 建议看一下这篇中的图：<a href="https://juejin.cn/post/6994959998283907102?share_token=8eaee3de-87a2-4aea-961f-0c8522270c5b" target="_blank" rel="noopener noreferrer">15张图，20分钟吃透Diff算法核心原理，我说的！！！(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote></blockquote> <h3 id="_4-promise-all实现"><a href="#_4-promise-all实现" class="header-anchor">#</a> 4. promise.all实现</h3> <p><strong>1) 核心思路</strong></p> <ol><li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数</li> <li>这个方法返回一个新的 promise 对象，</li> <li>遍历传入的参数，用Promise.resolve()将参数&quot;包一层&quot;，使其变成一个promise对象</li> <li>参数所有回调成功才是成功，返回值数组与参数顺序一致</li> <li>参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。</li></ol> <p><strong>2）实现代码</strong></p> <p>一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">promiseAll</span><span class="token punctuation">(</span><span class="token parameter">promises</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">argument must be a array</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> resolvedCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> promiseNum <span class="token operator">=</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">var</span> resolvedResult <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promiseNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        resolvedCounter<span class="token operator">++</span><span class="token punctuation">;</span>
        resolvedResult<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedCounter <span class="token operator">==</span> promiseNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>resolvedResult<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token parameter">error</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// test</span>
<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">promiseAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p3<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// [3, 1, 2]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_2022-01-30"><a href="#_2022-01-30" class="header-anchor">#</a> 2022.01.30</h2> <h3 id="_1-水平垂直居中的方法"><a href="#_1-水平垂直居中的方法" class="header-anchor">#</a> 1.水平垂直居中的方法</h3> <blockquote><p><a href="https://juejin.cn/post/7009662518406676488" target="_blank" rel="noopener noreferrer">【青训营】做面试题般回顾前端基础知识CSS篇 - 4 弹性布局与经典面试题CSS实现垂直居中 - 掘金 (juejin.cn)(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>利用flex布局有两种方法；</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.father</span><span class="token punctuation">{</span>
 <span class="token property">display</span><span class="token punctuation">:</span>flex<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.son</span><span class="token punctuation">{</span>
 <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.father</span><span class="token punctuation">{</span>
 <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
 <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token comment">/* 水平居中 */</span>
 <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token comment">/* 垂直居中 */</span>
<span class="token punctuation">}</span>
</code></pre></div><p>利用绝对定位有两种方法；</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.father</span><span class="token punctuation">{</span>
 <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.son</span><span class="token punctuation">{</span>
 <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
 <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
 <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
 <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
 <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
 <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.father</span><span class="token punctuation">{</span>
 <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.son</span><span class="token punctuation">{</span>
 <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
 <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
 <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
 <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span>-50%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 需要考虑浏览器兼容问题 */</span>
 <span class="token comment">/* 上面这行等价于下面两行代码，需要知道子盒子的宽高~ */</span>
 <span class="token property">margin-top</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span><span class="token comment">/* 子盒子高度的一半50px */</span>
 <span class="token property">margin-left</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span> <span class="token comment">/* 子盒子宽度的一半100px */</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>还有一种利用行内元素特性做的居中</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">line-height</span><span class="token punctuation">:</span>height<span class="token punctuation">;</span>
<span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span>
</code></pre></div></blockquote> <h3 id="_2-es6有哪些新特性"><a href="#_2-es6有哪些新特性" class="header-anchor">#</a> 2.ES6有哪些新特性?</h3> <blockquote><p>引用阮老师的这本口碑爆棚的 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener noreferrer">ECMAScript 6 入门 (opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的目录👇</p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212124045.png" alt="image"></p></blockquote> <ul><li><p>let声明变量和const声明常量，两个都有块级作用域</p> <ul><li>ES5中的var是没有块级作用域的，并且var有变量提升</li></ul></li> <li><p>箭头函数</p> <ul><li>ES6中的函数定义不再使用关键字function()，而是利用了()=&gt;来进行定义</li></ul></li> <li><p>模板字符串</p> <ul><li>模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串</li></ul></li> <li><p>解构赋值</p> <ul><li>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值
<ul><li>数组解构</li> <li>对象解构</li></ul></li></ul></li> <li><p>for of循环</p> <ul><li>for...of循环可以遍历——
<ul><li>数组</li> <li>Set和Map结构</li> <li>某些类似数组的对象、对象</li> <li>以及字符串</li></ul></li></ul></li> <li><p>import、export导入导出 ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用</p></li> <li><p>set数据结构</p> <ul><li>Set数据结构，类似数组。所有的数据都是唯一的，<strong>没有重复的值</strong>。它本身是一个构造函数</li></ul></li> <li><p><code>...</code> 展开运算符</p> <ul><li>可以将数组或对象里面的值展开；还可以将多个值收集为一个变量</li></ul></li> <li><p>修饰器 @</p> <ul><li>decorator是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数</li></ul></li> <li><p>class 类的继承</p> <ul><li>ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念</li></ul></li> <li><p>async、await</p> <ul><li><p>使用 async/await, 搭配promise,可以通过编写<strong>形似同步的代码</strong>来处理异步流程, 提高代码的简洁性和可读性</p></li> <li><p>async 用于申明一个 function 是异步的，而 await 用于<strong>等待一个异步方法执行完成</strong></p> <ul><li><p>简单来说</p> <blockquote><div class="language-text extra-class"><pre class="language-text"><code>如果await等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。

如果await等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。
</code></pre></div></blockquote></li></ul></li></ul></li> <li><p>promise</p> <ul><li>Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大</li></ul></li> <li><p>Symbol BigInt …</p> <ul><li>Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的</li></ul></li> <li><p>Proxy代理</p> <ul><li>使用代理（Proxy）监听对象的操作，然后可以做一些相应的事情</li></ul></li></ul> <h3 id="_3-宏任务和微任务都有哪些-有什么区别"><a href="#_3-宏任务和微任务都有哪些-有什么区别" class="header-anchor">#</a> 3.宏任务和微任务都有哪些？有什么区别？</h3> <blockquote><p>推荐文章 <a href="https://segmentfault.com/a/1190000012806637" target="_blank" rel="noopener noreferrer">10分钟理解JS引擎的执行机制 - SegmentFault 思否(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="http://r9cclbbs3.hn-bkt.clouddn.com/20220212124053.png" alt="clipboard.png"></p></blockquote> <h5 id="_1-宏任务"><a href="#_1-宏任务" class="header-anchor">#</a> 1. 宏任务</h5> <ul><li>I/O</li> <li>setTimeout</li> <li>setInterval</li> <li>setImmediate</li></ul> <h5 id="_2-微任务"><a href="#_2-微任务" class="header-anchor">#</a> 2. 微任务</h5> <ul><li>Promise</li></ul> <h5 id="_3-区别"><a href="#_3-区别" class="header-anchor">#</a> 3. 区别</h5> <ul><li>执行顺序
<ul><li>当执行栈为空时 ， 先执行微任务 ， 后执行宏任务</li></ul></li> <li>进程的切换为宏任务 ， 线程的切换为微任务。</li></ul> <h3 id="_4-力扣-1-两数之和-opens-new-window"><a href="#_4-力扣-1-两数之和-opens-new-window" class="header-anchor">#</a> 4.力扣：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener noreferrer">1.两数之和(opens new window)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <ul><li><code>哈希表逆向思维</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">twoSum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    	<span class="token keyword">else</span><span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/Front-end-notes/beautyAlgorithms/11.html" class="prev">
            ⚡GitHub 上 170K+ Star 的前端学习的数据结构与算法项目
          </a></span> <span class="next"><a href="/Front-end-notes/studyeveryday/study2022-2.html">
            🙀2022年2月
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-12" class="sidebar-link reco-side-_2022-01-12" data-v-cb1513f6>2022.01.12</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1、css篇-定位中-absolute-与-fixed-共同点与不同点" class="sidebar-link reco-side-_1、css篇-定位中-absolute-与-fixed-共同点与不同点" data-v-cb1513f6>1、css篇：定位中，absolute 与 fixed 共同点与不同点</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2、javascript篇-闭包的概念及特点" class="sidebar-link reco-side-_2、javascript篇-闭包的概念及特点" data-v-cb1513f6>2、JavaScript篇：闭包的概念及特点</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3、算法-说一下递归和迭代的区别是什么-各有什么优缺点" class="sidebar-link reco-side-_3、算法-说一下递归和迭代的区别是什么-各有什么优缺点" data-v-cb1513f6>3、算法：说一下递归和迭代的区别是什么，各有什么优缺点？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4、力扣101-对称二叉树-给你一个二叉树的根节点root-检查它是否轴对称。" class="sidebar-link reco-side-_4、力扣101-对称二叉树-给你一个二叉树的根节点root-检查它是否轴对称。" data-v-cb1513f6>4、力扣101.对称二叉树：给你一个二叉树的根节点root，检查它是否轴对称。</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-13" class="sidebar-link reco-side-_2022-01-13" data-v-cb1513f6>2022.01.13</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-箭头函数与普通函数的区别" class="sidebar-link reco-side-_1-箭头函数与普通函数的区别" data-v-cb1513f6>1.箭头函数与普通函数的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-this指向哪里" class="sidebar-link reco-side-_2-this指向哪里" data-v-cb1513f6>2.this指向哪⾥？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-扩展运算符的作用及使用场景" class="sidebar-link reco-side-_3-扩展运算符的作用及使用场景" data-v-cb1513f6>3.扩展运算符的作用及使用场景</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-217-存在重复元素" class="sidebar-link reco-side-_4-217-存在重复元素" data-v-cb1513f6>4.217. 存在重复元素</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-14" class="sidebar-link reco-side-_2022-01-14" data-v-cb1513f6>2022.01.14</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-讲一下强缓存和协商缓存的区别" class="sidebar-link reco-side-_1-讲一下强缓存和协商缓存的区别" data-v-cb1513f6>1.讲一下强缓存和协商缓存的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-如何解决跨越问题" class="sidebar-link reco-side-_2-如何解决跨越问题" data-v-cb1513f6>2.如何解决跨越问题</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-对事件委托的理解以及其使用场景" class="sidebar-link reco-side-_3-对事件委托的理解以及其使用场景" data-v-cb1513f6>3.对事件委托的理解以及其使用场景</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-算法-最大数" class="sidebar-link reco-side-_4-算法-最大数" data-v-cb1513f6>4 算法，最大数</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-17" class="sidebar-link reco-side-_2022-01-17" data-v-cb1513f6>2022.01.17</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-解释一下javascript的同源策略" class="sidebar-link reco-side-_1-解释一下javascript的同源策略" data-v-cb1513f6>1.解释一下JavaScript的同源策略</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-如何实现异步编程" class="sidebar-link reco-side-_2-如何实现异步编程" data-v-cb1513f6>2.如何实现异步编程</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-事件模型的三个阶段" class="sidebar-link reco-side-_3-事件模型的三个阶段" data-v-cb1513f6>3.事件模型的三个阶段</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-手写快速排序" class="sidebar-link reco-side-_4-手写快速排序" data-v-cb1513f6>4 手写快速排序</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-18" class="sidebar-link reco-side-_2022-01-18" data-v-cb1513f6>2022.01.18</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-cookie-sessionstorage-localstorage-的区别" class="sidebar-link reco-side-_1-cookie-sessionstorage-localstorage-的区别" data-v-cb1513f6>1.cookie sessionstorage localstorage 的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-浏览器的渲染过程" class="sidebar-link reco-side-_2-浏览器的渲染过程" data-v-cb1513f6>2.浏览器的渲染过程</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-渐进增强和优雅降级" class="sidebar-link reco-side-_3-渐进增强和优雅降级" data-v-cb1513f6>3.渐进增强和优雅降级</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-手写斐波那契数列" class="sidebar-link reco-side-_4-手写斐波那契数列" data-v-cb1513f6>4.手写斐波那契数列</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-19" class="sidebar-link reco-side-_2022-01-19" data-v-cb1513f6>2022.01.19</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-字面量new出来的对象和object-create-null-创建出来的对象有什么区别" class="sidebar-link reco-side-_1-字面量new出来的对象和object-create-null-创建出来的对象有什么区别" data-v-cb1513f6>1.字面量new出来的对象和Object.create(null)创建出来的对象有什么区别？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-数据类型检测的方式都有哪些" class="sidebar-link reco-side-_2-数据类型检测的方式都有哪些" data-v-cb1513f6>2.数据类型检测的方式都有哪些?</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-判断数组检测的方式都有哪些" class="sidebar-link reco-side-_3-判断数组检测的方式都有哪些" data-v-cb1513f6>3.判断数组检测的方式都有哪些?</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-new的具体操作过程" class="sidebar-link reco-side-_4-new的具体操作过程" data-v-cb1513f6>4.new的具体操作过程</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-20" class="sidebar-link reco-side-_2022-01-20" data-v-cb1513f6>2022.01.20</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1、实现一个三角形" class="sidebar-link reco-side-_1、实现一个三角形" data-v-cb1513f6>1、实现一个三角形</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2、javascript为什么要进行变量提升-它导致了什么问题" class="sidebar-link reco-side-_2、javascript为什么要进行变量提升-它导致了什么问题" data-v-cb1513f6>2、JavaScript为什么要进行变量提升，它导致了什么问题？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3、实现节流函数和防抖函数" class="sidebar-link reco-side-_3、实现节流函数和防抖函数" data-v-cb1513f6>3、实现节流函数和防抖函数</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-21" class="sidebar-link reco-side-_2022-01-21" data-v-cb1513f6>2022.01.21</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-http-1-0-1-1-2-0-3-0对应的改进点-2-0实现多路复用的底层原理" class="sidebar-link reco-side-_1-http-1-0-1-1-2-0-3-0对应的改进点-2-0实现多路复用的底层原理" data-v-cb1513f6>1.HTTP: 1.0 1.1 2.0 3.0对应的改进点，2.0实现多路复用的底层原理？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-js-call、apply、bind作用和区别" class="sidebar-link reco-side-_2-js-call、apply、bind作用和区别" data-v-cb1513f6>2.Js:  call、apply、bind作用和区别</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-数据结构-map-和-set-的区别" class="sidebar-link reco-side-_3-数据结构-map-和-set-的区别" data-v-cb1513f6>3.数据结构: Map 和 Set 的区别</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-22" class="sidebar-link reco-side-_2022-01-22" data-v-cb1513f6>2022.01.22</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-javascript中对象继承的方式有哪些" class="sidebar-link reco-side-_1-javascript中对象继承的方式有哪些" data-v-cb1513f6>1. JavaScript中对象继承的方式有哪些？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-实现异步加载方法的关键字有哪些" class="sidebar-link reco-side-_2-实现异步加载方法的关键字有哪些" data-v-cb1513f6>2. 实现异步加载方法的关键字有哪些？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-什么是js的事件循环-事件循环机制是什么" class="sidebar-link reco-side-_3-什么是js的事件循环-事件循环机制是什么" data-v-cb1513f6>3. 什么是JS的事件循环 ， 事件循环机制是什么？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-leetcode-20-有效的括号" class="sidebar-link reco-side-_4-leetcode-20-有效的括号" data-v-cb1513f6>4 leetcode 20 有效的括号</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-23" class="sidebar-link reco-side-_2022-01-23" data-v-cb1513f6>2022.01.23</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-let、const、var区别" class="sidebar-link reco-side-_1-let、const、var区别" data-v-cb1513f6>1. let、const、var区别</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-数组去重-的方法有哪些" class="sidebar-link reco-side-_2-数组去重-的方法有哪些" data-v-cb1513f6>2. ==数组去重==的方法有哪些？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-vue双向绑定的原理" class="sidebar-link reco-side-_3-vue双向绑定的原理" data-v-cb1513f6>3. vue双向绑定的原理</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-70-爬楼梯-力扣-leetcode-leetcode-cn-com" class="sidebar-link reco-side-_4-70-爬楼梯-力扣-leetcode-leetcode-cn-com" data-v-cb1513f6>4.70. 爬楼梯 - 力扣（LeetCode） (leetcode-cn.com)</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-24" class="sidebar-link reco-side-_2022-01-24" data-v-cb1513f6>2022.01.24</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-字面量创建对象和-new-创建对象有什么区别" class="sidebar-link reco-side-_1-字面量创建对象和-new-创建对象有什么区别" data-v-cb1513f6>1.字面量创建对象和 new 创建对象有什么区别，</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-new-内部都实现了什么-手写一个-new" class="sidebar-link reco-side-_1-new-内部都实现了什么-手写一个-new" data-v-cb1513f6>1‘.new 内部都实现了什么， 手写一个 new</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-和-有什么区别" class="sidebar-link reco-side-_2-和-有什么区别" data-v-cb1513f6>2.==和===有什么区别</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#对象的强制类型转换流程总结" class="sidebar-link reco-side-对象的强制类型转换流程总结" data-v-cb1513f6>对象的强制类型转换流程总结</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-在-js-中为什么-0-2-0-1-0-3" class="sidebar-link reco-side-_3-在-js-中为什么-0-2-0-1-0-3" data-v-cb1513f6>3.在 JS 中为什么 0.2+0.1&gt;0.3?</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-那为什么-0-2-0-3-0-5-呢" class="sidebar-link reco-side-_4-那为什么-0-2-0-3-0-5-呢" data-v-cb1513f6>4.那为什么 0.2+0.3=0.5 呢?</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_5-为什么-console-log-0-1-打印得到-0-1-呢" class="sidebar-link reco-side-_5-为什么-console-log-0-1-打印得到-0-1-呢" data-v-cb1513f6>5.为什么 console.log(0.1) 打印得到 0.1 呢</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-25" class="sidebar-link reco-side-_2022-01-25" data-v-cb1513f6>2022.01.25</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1、-三栏布局-有多少种-思路和代码" class="sidebar-link reco-side-_1、-三栏布局-有多少种-思路和代码" data-v-cb1513f6>1、==三栏布局==，有多少种？思路和代码</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2、css中定位有多少个值-每个值有什么特点" class="sidebar-link reco-side-_2、css中定位有多少个值-每个值有什么特点" data-v-cb1513f6>2、css中定位有多少个值，每个值有什么特点</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3、对bfc的理解-如何创建bfc" class="sidebar-link reco-side-_3、对bfc的理解-如何创建bfc" data-v-cb1513f6>3、对BFC的理解，如何创建BFC</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4、给定一个由-整数-组成的-非空-数组所表示的非负整数-在该数的基础上加一。" class="sidebar-link reco-side-_4、给定一个由-整数-组成的-非空-数组所表示的非负整数-在该数的基础上加一。" data-v-cb1513f6>4、给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-26" class="sidebar-link reco-side-_2022-01-26" data-v-cb1513f6>2022.01.26</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-你了解cdn吗-说一下cdn" class="sidebar-link reco-side-_1-你了解cdn吗-说一下cdn" data-v-cb1513f6>1.你了解cdn吗？说一下cdn</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-https的加密策略" class="sidebar-link reco-side-_2-https的加密策略" data-v-cb1513f6>2.Https的加密策略</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-js如何进行垃圾回收的-如果回收出现循环引用会导致什么" class="sidebar-link reco-side-_3-js如何进行垃圾回收的-如果回收出现循环引用会导致什么" data-v-cb1513f6>3.JS如何进行垃圾回收的？如果回收出现循环引用会导致什么？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-vue中组件间传值有哪些方法呢" class="sidebar-link reco-side-_4-vue中组件间传值有哪些方法呢" data-v-cb1513f6>4.Vue中组件间传值有哪些方法呢？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_5-算法题-最大回文子串-opens-new-window" class="sidebar-link reco-side-_5-算法题-最大回文子串-opens-new-window" data-v-cb1513f6>5.算法题 最大回文子串(opens new window)</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-27" class="sidebar-link reco-side-_2022-01-27" data-v-cb1513f6>2022.01.27</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-如何判断两个链表是否相交" class="sidebar-link reco-side-_1-如何判断两个链表是否相交" data-v-cb1513f6>1.如何判断两个链表是否相交?</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-对vue的响应式原理有了解么-可以简单的说一下么" class="sidebar-link reco-side-_2-对vue的响应式原理有了解么-可以简单的说一下么" data-v-cb1513f6>2.对vue的响应式原理有了解么，可以简单的说一下么？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-【2】cookie是为了解决什么问题-session-localstorage-sessionstorage-这三者的区别是啥呢" class="sidebar-link reco-side-_3-【2】cookie是为了解决什么问题-session-localstorage-sessionstorage-这三者的区别是啥呢" data-v-cb1513f6>3.【2】cookie是为了解决什么问题，session, localStorage, sessionStorage，这三者的区别是啥呢？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-给你一棵树-树上的每条边权值都是1-求树上两个节点的距离-使得路径最大" class="sidebar-link reco-side-_4-给你一棵树-树上的每条边权值都是1-求树上两个节点的距离-使得路径最大" data-v-cb1513f6>4.给你一棵树，树上的每条边权值都是1，求树上两个节点的距离，使得路径最大</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-28" class="sidebar-link reco-side-_2022-01-28" data-v-cb1513f6>2022.01.28</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-力扣3-无重复字符的最长子串" class="sidebar-link reco-side-_1-力扣3-无重复字符的最长子串" data-v-cb1513f6>1.力扣3 无重复字符的最长子串</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-css优先级是怎么计算的" class="sidebar-link reco-side-_2-css优先级是怎么计算的" data-v-cb1513f6>2.css优先级是怎么计算的</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-typeof和instanceof的区别" class="sidebar-link reco-side-_3-typeof和instanceof的区别" data-v-cb1513f6>3.typeof和instanceof的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-v-if和v-show区别" class="sidebar-link reco-side-_4-v-if和v-show区别" data-v-cb1513f6>4.v-if和v-show区别</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-29" class="sidebar-link reco-side-_2022-01-29" data-v-cb1513f6>2022.01.29</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-null和undefined的区别" class="sidebar-link reco-side-_1-null和undefined的区别" data-v-cb1513f6>1. null和undefined的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-【2】判断this指向的几种方法" class="sidebar-link reco-side-_2-【2】判断this指向的几种方法" data-v-cb1513f6>2. 【2】判断this指向的几种方法</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-vue-react中key的作用-为什么不建议用index作为key" class="sidebar-link reco-side-_3-vue-react中key的作用-为什么不建议用index作为key" data-v-cb1513f6>3. vue/React中key的作用，为什么不建议用index作为key</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-promise-all实现" class="sidebar-link reco-side-_4-promise-all实现" data-v-cb1513f6>4. promise.all实现</a></li><li class="level-2" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2022-01-30" class="sidebar-link reco-side-_2022-01-30" data-v-cb1513f6>2022.01.30</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_1-水平垂直居中的方法" class="sidebar-link reco-side-_1-水平垂直居中的方法" data-v-cb1513f6>1.水平垂直居中的方法</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_2-es6有哪些新特性" class="sidebar-link reco-side-_2-es6有哪些新特性" data-v-cb1513f6>2.ES6有哪些新特性?</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_3-宏任务和微任务都有哪些-有什么区别" class="sidebar-link reco-side-_3-宏任务和微任务都有哪些-有什么区别" data-v-cb1513f6>3.宏任务和微任务都有哪些？有什么区别？</a></li><li class="level-3" data-v-cb1513f6><a href="/Front-end-notes/studyeveryday/study2022-1.html#_4-力扣-1-两数之和-opens-new-window" class="sidebar-link reco-side-_4-力扣-1-两数之和-opens-new-window" data-v-cb1513f6>4.力扣：1.两数之和(opens new window)</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/Front-end-notes/assets/js/app.fce70604.js" defer></script><script src="/Front-end-notes/assets/js/3.b45189e7.js" defer></script><script src="/Front-end-notes/assets/js/1.62c193a0.js" defer></script><script src="/Front-end-notes/assets/js/51.dc86cabf.js" defer></script>
  </body>
</html>
